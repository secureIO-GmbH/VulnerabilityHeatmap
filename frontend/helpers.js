import moment from "moment";

let dialog;
if (typeof document !== "undefined") {
  dialog = document.querySelector("dialog");
  const closeButton = document.querySelector("dialog button");

  // "Close" button closes the dialog
  closeButton.addEventListener("click", () => {
    dialog.close();
  });
}

function getRandomNumber(max) {
  return Math.round(Math.random() * (max - 1));
}

export function getLastDayOfWeek(weekStr) {
  const [weekString, year] = weekStr.split(" ");
  const weekNumber = weekString.replace("CW", "");

  // Get the current year and week number
  const today = moment();
  const currentYear = today.year();
  const currentWeekNumber = today.isoWeek();
  const isCurrentWeek =
    parseInt(year) === currentYear &&
    parseInt(weekNumber) === currentWeekNumber;
  if (isCurrentWeek) {
    return today;
  }

  const firstDayOfWeek = moment()
    .year(year)
    .isoWeek(weekNumber)
    .startOf("isoWeek");
  const lastDayOfWeek = firstDayOfWeek.clone().endOf("isoWeek");

  return lastDayOfWeek;
}

export const SCANNER_TYPES = {
  sast: "Kiuwan",
  sca: "KiuwanLibraries",
  container: "Trivy",
  tm: "IriusRisk",
  dast: "Acunetix WVS",
};

export const COLOR_RANGE = {
  info: "#00b050", // green
  low: "#92d050", // light green
  medium: "#ffff00", // yellow
  high: "#ff0000", // red
  critical: "#c00000", // dark red
};

export function filterScansByScannerType(scans, selectedScannerType) {
  return scans.filter(function (scan) {
    if (selectedScannerType && selectedScannerType !== "all") {
      if (selectedScannerType === "sast") {
        return (
          scan.scannerName === SCANNER_TYPES["sast"] ||
          scan.scannerName === SCANNER_TYPES["sca"]
        );
      }
      return scan.scannerName === SCANNER_TYPES[selectedScannerType];
    }

    // default:
    return (
      scan.scannerName === SCANNER_TYPES.sast ||
      scan.scannerName === SCANNER_TYPES.sca ||
      scan.scannerName === SCANNER_TYPES.container ||
      scan.scannerName === SCANNER_TYPES.tm ||
      scan.scannerName === SCANNER_TYPES.dast
    );
  });
}

// IMPORTANT, read this:
//  https://momentjscom.readthedocs.io/en/latest/moment/02-get-set/10-week/
// "The week of the year varies depending on which day is the first day of the
// week(Sunday, Monday, etc), and which week is the first week of the year"
export function isInCalendarWeek(timestamp, week, year) {
  const date = moment(timestamp);

  // console.log('date', date);
  // console.log('week', date.week());
  // console.log('year', date.year());

  const weekOfDate = date.week();
  const yearOfDate = date.year();

  return weekOfDate === week && yearOfDate === year;
}

export function getScansOfCalendarWeek(scans, calendarWeek, year) {
  return scans.filter((scan) => {
    return isInCalendarWeek(scan.importTime, calendarWeek, year);
  });
}

export const dialogObject = {
  open: function (html) {
    document.querySelector("dialog .dialog-content").innerHTML = html;
    dialog.showModal();
  },
  close: function () {
    dialog.close();
  },
};

function getScanDummy() {
  return {
    // 	numberClosedVulnerabilities: 0
    numberTotalVulnerabilities: 0,
    numberCriticalVulnerabilities: 0,
    numberHighVulnerabilities: 0,
    numberMediumVulnerabilities: 0,
    numberLowVulnerabilities: 0,
    numberInfoVulnerabilities: 0,
    findings: [],
    // 	numberNewVulnerabilities: 0
    // 	numberOldVulnerabilities: 0
    // 	numberRepeatFindings: 0
    // 	numberRepeatResults: 0
    // 	numberResurfacedVulnerabilities: 0
    // 	numberUnassignedVulnerabilities: 0
  };
}
/**
 * We want to have "historical" point of view of vulnerabilities over time.
 * To address this, an accurate historical view of vulnerabilities for each
 * scan type per calendar week, taking into account the findings from
 * previous scans, a cumulative approach is implemented. This approach
 * ensures that the current week's representation includes unresolved
 * vulnerabilities from previous weeks, providing a more realistic view of
 * the application's security posture over time.
 *
 * Also have a look at the unit tests to fully understand this function.
 */
export function normalizeScansForHistoricalView(scans, startDate, endDate) {
  // sort ascending by importTime
  scans.sort(function (a, b) {
    return a.importTime - b.importTime;
  });

  // first add data structure which holds scans per week in the whole range
  const scansPerWeek = {};

  const lastTimestamp = moment(endDate).unix();
  let timestamp = moment(startDate).unix();
  let weeksToAdd = 0;

  while (timestamp <= lastTimestamp) {
    const date = moment(startDate).add(weeksToAdd, "weeks");
    timestamp = date.unix();
    weeksToAdd++;

    const str = "CW" + date.week() + " " + date.year();
    scansPerWeek[str] = {
      // this array will hold all scans happened in this week
      scans: [],

      // this array will hold ONLY the LATEST scans in a current week, ex:
      // w1: trivy1, sast1, sast2, sast3 -> [trivy1, sast3]
      // w2: [] -> [trivy1, sast3]
      // w3: [sast4] -> [trivy1, sast4]
      // usw...
      latestScansPerTypeInThisWeek: {},

      // for each week we want to have simple stats per type
      sumTotal: 0,
      sumCritical: 0,
      sumHigh: 0,
      sumMedium: 0,
      sumLow: 0,
      sumInfo: 0,

      sast: 0,
      container: 0,
      // tm: 0,
      // dast: 0,
    };
  }

  // filter the scans by calendar week
  for (const scan of scans) {
    scan.date = moment(scan.importTime);
    const weekOfDate = scan.date.week();
    const yearOfDate = scan.date.year();
    const str = "CW" + weekOfDate + " " + yearOfDate;

    // if we have scans which are not in the user selected date range, ignore them:
    if (!scansPerWeek[str]) {
      continue;
    }

    scansPerWeek[str].scans.push(scan);
  }

  // then get the latest scan per scanner type in a week.
  // if there is none, use the data from the last week.
  let latestScansPerTypeFromLastWeek = null;
  for (const [weekStr, obj] of Object.entries(scansPerWeek)) {
    const scansInWeek = obj.scans;

    let latestScansPerType = {};
    latestScansPerType[SCANNER_TYPES.sast] = getScanDummy();
    latestScansPerType[SCANNER_TYPES.sca] = getScanDummy();
    latestScansPerType[SCANNER_TYPES.container] = getScanDummy();
    latestScansPerType[SCANNER_TYPES.tm] = getScanDummy();

    // use data from last week
    if (latestScansPerTypeFromLastWeek) {
      latestScansPerType = latestScansPerTypeFromLastWeek;
    }

    // what we also want is smt like "findings per scanner type" of current weekdays.
    // ex: if there are no trivy findings this week, maybe there are from last(s)!!!
    // then we can always just check latestFindings.each and see if there is at LEAST ONE critical sla violation for example, this is enough to make it red

    // For each "group", count the *** number of findings with SLA violations *** (where sla_days_remaining is negative or sla_expiration_date has passed).

    // > 3 ? dark red
    // einfach mal als beispiel und dann meeting morgen!

    // Question:
    // die frage ist: welcher? was wenn ein finding in time und ein anderes More than 5 days past SLA!??!?!?!

    // - In time (30-10 days to SLA) -> green
    //   - Prewarning (10 days to SLA) -> light green
    //   - Prewarning (5 days to SLA) -> yellow
    //   - Past SLA -> red
    //   - More than 5 days past SLA -> dark red

    // This is interesting when looking at *one* finding. In a certain calendar week, we may have endDate.g. 50 kiuwan and 50 trivy findings, some in time, some may are Past SLA. You write: "We would take into account the vulnerability with the worst SLA for the calculation.

    // TODO: add function ignoreFinding() -> duplicate,risk_accepted etc!
    for (const scan of scansInWeek) {
      scan.date = moment(scan.importTime);
      latestScansPerType[scan.scannerName] = scan;
    }

    let sumTotal = 0,
      sumCritical = 0,
      sumHigh = 0,
      sumMedium = 0,
      sumLow = 0,
      sumInfo = 0,
      sast = 0,
      container = 0,
      tm = 0;

    // eslint-disable-next-line no-unused-vars
    for (const [scannerName, scan] of Object.entries(latestScansPerType)) {
      sumTotal += scan.numberTotalVulnerabilities;
      sumCritical += scan.numberCriticalVulnerabilities;
      sumHigh += scan.numberHighVulnerabilities;
      sumMedium += scan.numberMediumVulnerabilities;
      sumLow += scan.numberLowVulnerabilities;
      sumInfo += scan.numberInfoVulnerabilities;

      if (scan.scannerName === SCANNER_TYPES.container) {
        container += scan.numberTotalVulnerabilities;
      }
      if (
        scan.scannerName === SCANNER_TYPES.sast ||
        scan.scannerName === SCANNER_TYPES.sca
      ) {
        sast += scan.numberTotalVulnerabilities;
      } else if (scan.scannerName === SCANNER_TYPES.tm) {
        tm += scan.numberTotalVulnerabilities;
      }
    }
    scansPerWeek[weekStr].sumTotal = sumTotal;
    scansPerWeek[weekStr].sumCritical = sumCritical;
    scansPerWeek[weekStr].sumHigh = sumHigh;
    scansPerWeek[weekStr].sumMedium = sumMedium;
    scansPerWeek[weekStr].sumLow = sumLow;
    scansPerWeek[weekStr].sumInfo = sumInfo;
    scansPerWeek[weekStr].sast = sast;
    scansPerWeek[weekStr].container = container;
    scansPerWeek[weekStr].tm = tm;

    // always store the latest scans per type of this week:
    scansPerWeek[weekStr].latestScansPerTypeInThisWeek = Object.assign(
      {},
      latestScansPerType,
    );

    // remember last week's scans
    latestScansPerTypeFromLastWeek = latestScansPerType;
  }

  // console.log(scansPerWeek);

  return scansPerWeek;
}

/**
 * Calculates the y-value for the heatmap of a calendar week,
 * based on all scans and their findings happened in this week.
 *
 * How does the sla calculation work:
 *
 * Example:
 * 	finding.date = 1.Jan (critical, i.e. time until breach=30d)
 * 	breach date: 31.Jan
 *  -------------------
 *    dateOfCalculation (i.e. last day of week or today if in current week): 2.Jan (finding is 1 day old)
 * 	  sla_days_remaining: 31.Jan - 2.Jan = 29 days (NO BREACH)
 *	or:
 *    dateOfCalculation 30.April (finding is 31+28+31+30 = 120 day old)
 *    sla_days_remaining: 31.Jan - 30.April = 28+31+30 = -91 days after breach

 Use moment to calculate this: (https://jsfiddle.net/9a6dsbtw/2/)
  let a = moment("2024-01-31 00:00:00") // breach date
	let b = moment("2024-04-31 00:00:00") // date of calc
	let diff = a.diff(b, "days");
	alert(diff)

 *
 * @scansOfCurrentWeek only the last scans per scanner type for passed week (cumulative)
 * @weekStr: e.g. "CW4 2024"
 *
 * See "colorScale" in main.js
 */
export function calculateSLAColorForWeek(weekStr, scansOfCurrentWeek) {
  // NOTE: get the date of the last day of the the passed week
  // This ensures that all findings within that week are evaluated consistently,
  // and the SLA status is calculated based on a fixed point in time.
  // But: if it is the current week, use *today*
  const lastDayOfWeek = getLastDayOfWeek(weekStr);
  const allFindings = [];
  for (const obj of Object.entries(scansOfCurrentWeek)) {
    const scan = obj[1];
    for (const finding of scan.findings) {
      allFindings.push(finding);
    }
  }

  const slaLookup = {
    // critical rows
    0: {
      // zero critical vulns
      // high columns:
      0: 0,
      ">=45": 0,
      "15-45": 1,
      "1-15": 2,
      "<=0": 3,
      "<= -15": 4,
    },
    ">=10": {
      // high columns:
      0: 0,
      ">=45": 0,
      "15-45": 1,
      "1-15": 2,
      "<=0": 3,
      "<= -15": 4,
    },
    ">0 && <10": {
      // high columns:
      0: 1,
      ">=45": 1,
      "15-45": 1,
      "1-15": 2,
      "<=0": 3,
      "<= -15": 4,
    },
    ">0 && <=5": {
      // high columns:
      0: 2,
      ">=45": 2,
      "15-45": 2,
      "1-15": 2,
      "<=0": 3,
      "<= -15": 4,
    },
    "<0 && > -5": {
      // high columns:
      0: 3,
      ">=45": 3,
      "15-45": 3,
      "1-15": 3,
      "<=0": 4,
      "<= -15": 4,
    },
    "< -5": {
      // high columns:
      0: 4,
      ">=45": 4,
      "15-45": 4,
      "1-15": 4,
      "<=0": 4,
      "<= -15": 4,
    },
  };

  // first find the worst sla for high and critical (i.e. smallest "sla_days_remaining")
  let worstHighFinding, worstCriticalFinding;

  const filteredFindings = allFindings.filter((f) => {
    return f.severity === "High" || f.severity === "Critical";
  });

  console.log("\n------start");
  for (const finding of filteredFindings) {
    // TODO NOW, correct????
    console.log(
      "finding.sla_expiration_date",
      finding.sla_expiration_date.toString(),
    );
    console.log("lastDayOfWeek", lastDayOfWeek);
    finding.sla_days_remaining_custom = moment(
      moment(finding.sla_expiration_date),
    ).diff(lastDayOfWeek, "days");
    console.log(
      "TODO NOW sla_days_remaining_custom=",
      finding.sla_days_remaining_custom,
    );

    // find the worst critical or high finding
    if (!worstHighFinding && finding.severity === "High") {
      worstHighFinding = finding;
    }
    if (!worstCriticalFinding && finding.severity === "Critical") {
      worstCriticalFinding = finding;
    }

    if (
      finding.severity === "High" &&
      finding.sla_days_remaining_custom <
        worstHighFinding.sla_days_remaining_custom
    ) {
      worstHighFinding = finding;
    }

    if (
      finding.severity === "Critical" &&
      finding.sla_days_remaining_custom <
        worstCriticalFinding.sla_days_remaining_custom
    ) {
      worstCriticalFinding = finding;
    }
  }

  if (!worstHighFinding && !worstCriticalFinding) {
    return 0;
  }

  function getColorCode(worstCriticalFinding, worstHighFinding) {
    let criticalSla = worstCriticalFinding
      ? worstCriticalFinding.sla_days_remaining_custom
      : null;
    let highSla = worstHighFinding
      ? worstHighFinding.sla_days_remaining_custom
      : null;
    let criticalKey = null;
    let highKey = null;

    if (criticalSla === null) {
      criticalKey = 0;
    } else if (criticalSla >= 10) {
      criticalKey = ">=10";
    } else if (criticalSla >= 5) {
      criticalKey = ">0 && <10";
    } else if (criticalSla >= 0) {
      criticalKey = ">0 && <=5";
    } else if (criticalSla > -5 && criticalSla < 0) {
      criticalKey = "<0 && > -5";
    } else if (criticalSla <= -5) {
      criticalKey = "< -5";
    }

    if (highSla === null) {
      highKey = 0;
    } else if (highSla >= 45) {
      highKey = ">=45";
    } else if (highSla >= 15) {
      highKey = "15-45";
    } else if (highSla >= 1) {
      highKey = "1-15";
    } else if (highSla <= 0 && highSla > -15) {
      highKey = "<=0";
    } else if (highSla <= -15) {
      highKey = "<= -15";
    }

    // console.log(worstCriticalFinding, criticalKey, highKey);
    return slaLookup[criticalKey][highKey];
  }

  const colorCode = getColorCode(worstCriticalFinding, worstHighFinding);
  return colorCode;
}

/**
 * We need some random data for demo.
 */
export function generateRandomDataForDemo(startDate, endDate) {
  // TODO now: also generate some jira demo data to test the if/else logic!
  const apps = [
    { name: "App1", scans: [] },
    { name: "App2", scans: [] },
    { name: "App3", scans: [] },
    { name: "App4", scans: [] },
    { name: "App5", scans: [] },
    { name: "App6", scans: [] },
  ];

  console.log(startDate, endDate);

  // generate calendar weeks from start_date to end_date
  const calendarWeeks = [
    {
      week: startDate.week(),
      year: endDate.year(),
    },
  ];

  let timestamp = startDate.unix();
  const lastTimestamp = endDate.unix();

  let weeksToAdd = 1;
  while (timestamp <= lastTimestamp) {
    const date = startDate.clone().add(weeksToAdd, "weeks");
    timestamp = date.unix();
    weeksToAdd++;

    calendarWeeks.push({
      week: date.week(),
      year: date.year(),
    });
  }

  function getRandomScannerName() {
    const num = getRandomNumber(2);
    if (num === 0) {
      return "Trivy";
    } else {
      return "Kiuwan";
    }
  }

  function getRandomSeverity() {
    const num = getRandomNumber(4);
    const sevs = ["Critical", "High", "Medium", "Low"];
    return sevs[num];
  }

  for (const app of apps) {
    let count = 0;
    // in each week we want to generate some random number of scans
    for (const weekObj of calendarWeeks) {
      // after 14 weeks we stop adding scans, so we get some nice sla violations
      if (count++ > 14) {
        continue;
      }

      const numScans = getRandomNumber(10); // scans in this week

      for (let scanIdx = 0; scanIdx < numScans; scanIdx++) {
        console.log(weekObj);
        const firstDayOfWeek = moment()
          .year(weekObj.year)
          .isoWeek(weekObj.week)
          .startOf("isoWeek");

        // generate a date inside THIS week
        const date = moment(
          firstDayOfWeek.add(getRandomNumber(5), "days").format("YYYY-MM-DD"),
        );

        const scan = {
          date: date,
          importTime: date.unix() * 1000,
          scannerName: getRandomScannerName(),
          findings: [],
        };

        let numFindings = getRandomNumber(30);
        const tmp = getRandomNumber(2);
        if (tmp === 1) {
          numFindings = 0; // it should be 0 findings more often
        }

        for (let j = 0; j < numFindings; j++) {
          let sla_expiration_date;
          const severity = getRandomSeverity();
          const clonedDate = date.clone();

          // TODO: test if this correctly comes from DefectDojo!!!!!!!!!!!!!!!!!!!!!!!
          if (severity === "Critical") {
            sla_expiration_date = clonedDate.add(30, "days");
          } else if (severity === "High") {
            sla_expiration_date = clonedDate.add(90, "days");
          } else {
            sla_expiration_date = clonedDate.add(100000, "days"); // no expiration date for <= medium
          }

          scan.findings.push({
            date: date,
            sla_expiration_date: sla_expiration_date.format("YYYY-MM-DD"),
            severity: severity,
          });
        }

        // count sums
        scan.numberTotalVulnerabilities = scan.findings.length;
        scan.numberCriticalVulnerabilities = scan.findings.filter(
          (f) => f.severity === "Critical",
        ).length;
        scan.numberHighVulnerabilities = scan.findings.filter(
          (f) => f.severity === "High",
        ).length;
        scan.numberMediumVulnerabilities = scan.findings.filter(
          (f) => f.severity === "Medium",
        ).length;
        scan.numberLowVulnerabilities = scan.findings.filter(
          (f) => f.severity === "Low",
        ).length;
        scan.numberInfoVulnerabilities = scan.findings.filter(
          (f) => f.severity === "Info",
        ).length;

        app.scans.push(scan);
      }
    }
  }

  return apps;
}
