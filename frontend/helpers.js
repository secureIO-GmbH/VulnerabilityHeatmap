import moment from "moment";

let dialog;
if (typeof document !== "undefined") {
  dialog = document.querySelector("dialog");
  const closeButton = document.querySelector("dialog button");

  // "Close" button closes the dialog
  closeButton.addEventListener("click", () => {
    dialog.close();
  });
}

export function logToUI(element, message) {
  element.innerHTML += message + "<br>";
}

export function filterScansOfWeek(scansOfCurrentWeek) {
  return scansOfCurrentWeek.filter(function (scan) {
    return (
      scan.scannerName === "Kiuwan" ||
      scan.scannerName === "KiuwanLibraries" ||
      scan.scannerName === "Trivy"
    );
  });
}

// IMPORTANT, read this:
//  https://momentjscom.readthedocs.io/en/latest/moment/02-get-set/10-week/
// "The week of the year varies depending on which day is the first day of the
// week(Sunday, Monday, etc), and which week is the first week of the year"
export function isInCalendarWeek(timestamp, week, year) {
  const date = moment(timestamp);

  // console.log('date', date);
  // console.log('week', date.week());
  // console.log('year', date.year());

  const weekOfDate = date.week();
  const yearOfDate = date.year();

  return weekOfDate === week && yearOfDate === year;
}

export function getScansOfCalendarWeek(scans, calendarWeek, year) {
  return scans.filter((scan) => {
    return isInCalendarWeek(scan.importTime, calendarWeek, year);
  });
}

export const dialogObject = {
  open: function (html) {
    document.querySelector("dialog .dialog-content").innerHTML = html;
    dialog.showModal();
  },
  close: function () {
    dialog.close();
  },
};

function getThreadfixScanDummy() {
  return {
    // 	numberClosedVulnerabilities: 0
    numberTotalVulnerabilities: 0,
    numberCriticalVulnerabilities: 0,
    numberHighVulnerabilities: 0,
    numberInfoVulnerabilities: 0,
    numberLowVulnerabilities: 0,
    numberMediumVulnerabilities: 0,
    // 	numberNewVulnerabilities: 0
    // 	numberOldVulnerabilities: 0
    // 	numberRepeatFindings: 0
    // 	numberRepeatResults: 0
    // 	numberResurfacedVulnerabilities: 0
    // 	numberUnassignedVulnerabilities: 0
  };
}
/**
 * We want to have "historical" point of view of vulnerabilities over time.To address this, an accurate historical view of vulnerabilities for each
 * scan type per calendar week, taking into account the findings from
 * previous scans, a cumulative approach is implemented. This approach
 * ensures that the current week's representation includes unresolved
 * vulnerabilities from previous weeks, providing a more realistic view of
 * the application's security posture over time.
 *
 * Also have a look at the unit tests to fully understand this function.
 */
export function normalizeScansForHistoricalView(scans, startDate, endDate) {
  // sort ascending by importTime
  scans.sort(function (a, b) {
    return a.importTime - b.importTime;
  });

  // first add data structure which holds scans per week in the whole range
  const scansPerWeek = {};

  const lastTimestamp = moment(endDate).unix();
  let timestamp = moment(startDate).unix();
  let weeksToAdd = 0;

  while (timestamp <= lastTimestamp) {
    const date = moment(startDate).add(weeksToAdd, "weeks");
    timestamp = date.unix();
    weeksToAdd++;

    const str = "CW" + date.week() + " " + date.year();
    scansPerWeek[str] = {
      scans: [],
      // for each week we want to have simple stats per type
      sumTotal: 0,
      sumCritical: 0,
      sumHigh: 0,
      sumMedium: 0,
      sumLow: 0,
      sumInfo: 0,

      sast: 0,
      container: 0,
      // tm: 0,
      // dast: 0,
    };
  }

  // filter the scans by calendar week
  for (const scan of scans) {
    scan.date = moment(scan.importTime);
    const weekOfDate = scan.date.week();
    const yearOfDate = scan.date.year();
    const str = "CW" + weekOfDate + " " + yearOfDate;

    // if we have scans which are not in the user selected date range, ignore them:
    if (!scansPerWeek[str]) {
      continue;
    }

    scansPerWeek[str].scans.push(scan);
  }

  // then get the latest scan per scanner type in a week.
  // if there is none, use the data from the last week.
  let latestScansPerTypeFromLastWeek = null;
  for (const [weekStr, obj] of Object.entries(scansPerWeek)) {
    const scansInWeek = obj.scans;

    let latestScansPerType = {
      Trivy: getThreadfixScanDummy(),
      Kiuwan: getThreadfixScanDummy(),
      KiuwanLibraries: getThreadfixScanDummy(),
    };

    // use data from last week
    if (latestScansPerTypeFromLastWeek) {
      latestScansPerType = latestScansPerTypeFromLastWeek;
    }

    for (const scan of scansInWeek) {
      scan.date = moment(scan.importTime);
      latestScansPerType[scan.scannerName] = scan;
    }

    let sumTotal = 0,
      sumCritical = 0,
      sumHigh = 0,
      sumMedium = 0,
      sumLow = 0,
      sumInfo = 0,
      sast = 0,
      container = 0;

    // eslint-disable-next-line no-unused-vars
    for (const [scannerName, scan] of Object.entries(latestScansPerType)) {
      sumTotal += scan.numberTotalVulnerabilities;
      sumCritical += scan.numberCriticalVulnerabilities;
      sumHigh += scan.numberHighVulnerabilities;
      sumMedium += scan.numberMediumVulnerabilities;
      sumLow += scan.numberLowVulnerabilities;
      sumInfo += scan.numberInfoVulnerabilities;

      if (scan.scannerName === "Trivy") {
        container += scan.numberTotalVulnerabilities;
      }
      if (
        scan.scannerName === "Kiuwan" ||
        scan.scannerName === "KiuwanLibraries"
      ) {
        sast += scan.numberTotalVulnerabilities;
      }
    }
    scansPerWeek[weekStr].sumTotal = sumTotal;
    scansPerWeek[weekStr].sumCritical = sumCritical;
    scansPerWeek[weekStr].sumHigh = sumHigh;
    scansPerWeek[weekStr].sumMedium = sumMedium;
    scansPerWeek[weekStr].sumLow = sumLow;
    scansPerWeek[weekStr].sumInfo = sumInfo;
    scansPerWeek[weekStr].sast = sast;
    scansPerWeek[weekStr].container = container;

    // remember last week's scans
    latestScansPerTypeFromLastWeek = latestScansPerType;
  }

  // console.log(scansPerWeek);

  return scansPerWeek;
}
