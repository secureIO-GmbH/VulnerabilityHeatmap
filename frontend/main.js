/**
 * Main file for the frontend
 */
import moment from "moment";
import {
  COLOR_RANGE,
  filterScansByScannerType,
  dialogObject,
  normalizeScansForHistoricalView,
  generateRandomDataForDemo,
  calculateSLAColorForWeek,
} from "./helpers.js";

// moment.locale('de');

if (document) {
  if (!document.getElementById("start_date").value) {
    document.getElementById("start_date").value = moment()
      .subtract(6, "months")
      .toISOString()
      .substr(0, 10);
  }
  if (!document.getElementById("end_date").value) {
    document.getElementById("end_date").value = new Date()
      .toISOString()
      .substr(0, 10);
  }

  document.querySelectorAll(".show-help").forEach((item) => {
    item.addEventListener("click", (event) => {
      event.preventDefault();
      const source = document.getElementById("help-template").innerHTML;
      const template = window.Handlebars.compile(source);
      const context = {};
      const html = template(context);
      dialogObject.open(html);
    });
  });
}

const factorCritical = 5,
  factorHigh = 4,
  factorMedium = 3,
  factorLow = 2,
  factorInfo = 1;

let CHART;

let API_URL = "https://" + window.location.host + "/api/dd";
let formProps, APPS;
const form = document.getElementById("form");
const selectScannerType = document.getElementById("scanner");
const scenarioSelect = document.getElementById("scenario");

form.addEventListener("submit", (event) => {
  event.preventDefault();

  const formData = new FormData(event.target);
  formProps = Object.fromEntries(formData);

  // TODO: select which tool in the UI?
  // API_URL +=
  //   "kiuwan?appName=" +
  //   formProps.search +
  //   "&startDate=" +
  //   moment(formProps.start_date).unix() * 1000 +
  //   "&endDate=" +
  // 	moment(formProps.end_date).unix() * 1000;

  console.log("init with form data ", formProps);
  initHeatmap();
});

const dateFields = document.getElementsByClassName("date-field");
Array.from(dateFields).forEach((f) => {
  f.addEventListener("change", (event) => {
    event.preventDefault();

    const formData = new FormData(form);
    formProps = Object.fromEntries(formData);
    initHeatmap();
  });
});

selectScannerType.addEventListener("change", (event) => {
  event.preventDefault();

  const formData = new FormData(form);
  formProps = Object.fromEntries(formData);
  initHeatmap();
});

scenarioSelect.addEventListener("change", (event) => {
  event.preventDefault();

  const formData = new FormData(form);
  formProps = Object.fromEntries(formData);
  initHeatmap();
});

// Fetch data from the node.js server, returns a promise with json data
function fetchData() {
  // test env means GitHub pages, no backend needed there
  if (NODE_ENV === "test") {
    return new Promise((resolve) => {
      resolve(
        generateRandomDataForDemo(
          moment(formProps.start_date),
          moment(formProps.end_date),
        ),
      );
    });
  }

  let url = API_URL;
  // if (formProps.search) {
  //   url += `?appName=${formProps.search}`;
  // }
  return fetch(url, {
    method: "GET",
  })
    .then(
      function (response) {
        return response.json();
      },
      function (error) {
        console.log("ERRORRRRRRRRRRR", error.message); // => String
      },
    )
    .catch((error) => {
      console.log("ERRORRRRRRRRRRR", error.message); // => String
    });
}

function setLoading(loading) {
  document.querySelector("#heatmap").innerHTML = loading;
  document.getElementById("lds-roller").style.display = loading
    ? "inline-block"
    : "none";
}

function initHeatmap() {
  if (CHART) {
    CHART.destroy();
  }
  setLoading("loading...");

  // generate calendar weeks from start_date to end_date
  const calendarWeeks = [
    {
      week: moment(formProps.start_date).isoWeek(),
      year: moment(formProps.start_date).year(),
    },
  ];

  let timestamp = moment(formProps.start_date).unix();
  const lastTimestamp = moment(formProps.endDate).unix();

  let weeksToAdd = 1;
  while (timestamp <= lastTimestamp) {
    const date = moment(formProps.start_date).add(weeksToAdd, "weeks");
    timestamp = date.unix();
    weeksToAdd++;

    calendarWeeks.push({
      week: date.isoWeek(),
      year: date.year(),
    });
  }
  console.log(
    "Calendar weeks between ",
    moment(formProps.start_date).isoWeek(),
    moment(formProps.end_date).isoWeek(),
    calendarWeeks,
  );

  function searchMatch(app) {
    return (
      formProps.search &&
      app.name.toLowerCase().indexOf(formProps.search.toLowerCase()) > -1
    );
  }

  function filteredApps() {
    return APPS.filter((app) => {
      if (!app.scans || app.scans.length === 0) {
        return false;
      }

      if (!formProps.tag && !formProps.search) {
        return true;
      }

      if (formProps.tag) {
        for (const tag of app.tags) {
          if (
            tag.name.toLowerCase().indexOf(formProps.tag.toLowerCase()) > -1
          ) {
            console.log("Matched tag: ", tag);
            if (searchMatch(app)) {
              return true;
            } else if (!formProps.search) {
              return true;
            }
          }
        }
      } else if (searchMatch(app)) {
        return true;
      } else if (!formProps.search) {
        return true;
      }
    });
  }

  function renderChart() {
    setLoading("");

    const appsFiltered = filteredApps();
    const series = [];

    for (const app of appsFiltered) {
      series.push({
        name: app.name,
        data: generateData(app),
      });
    }

    let height = appsFiltered.length * 70 + "px";
    if (appsFiltered.length <= 3) {
      height = "300px";
    }

    const colorScale = {
      ranges: [
        {
          from: 0,
          to: 0.9,
          name: "info",
          color: COLOR_RANGE.info, // green
        },
        {
          from: 0.901,
          to: 1.9,
          name: "low",
          color: COLOR_RANGE.low, // light green
        },
        {
          from: 1.901,
          to: 2.9,
          name: "medium",
          color: COLOR_RANGE.medium, // yellow
        },
        {
          from: 2.901,
          to: 3.9,
          name: "high",
          color: COLOR_RANGE.high, // red
        },
        {
          from: 3.901,
          to: 5, // >
          name: "critical",
          color: COLOR_RANGE.critical, // dark red
        },
        {
          from: 5.01,
          to: 1000000000000, // >
          name: "no scans in week",
          color: "#808080",
        },
      ],
    };

    const options = {
      series: series,
      // will not be shown if there is only one app (row)
      legend: {
        show: false,
        position: "top",
      },
      chart: {
        // height: "2000px", // TODO somehow inteligent calculating here?
        height: height, // https://apexcharts.com/docs/options/chart/height/
        type: "heatmap",
        events: {
          /**
           * Clicking a box should display some information about the clicked calendar week
           * like how many scans, why is the color how it is etc
           *
           * TODO: fetch tf scan details by scanIds including CVEs, maybe fetch EPSS etc...
           */
          click: function (event, chartContext, config) {
            // The last parameter config contains additional information like `seriesIndex` and `dataPointIndex` for cartesian charts
            // console.log(event, chartContext, config);
            const appName = config.globals.seriesNames[config.seriesIndex];
            const cwString = config.globals.labels[config.dataPointIndex];

            const appFound = APPS.find(function (app) {
              return app.name === appName;
            });

            const scansFilteredByWeeks = normalizeScansForHistoricalView(
              appFound.scans,
              formProps.start_date,
              formProps.end_date,
            );

            const scansOfCurrentWeek = scansFilteredByWeeks[cwString].scans;

            let sumSast = scansFilteredByWeeks[cwString].sast,
              sumContainer = scansFilteredByWeeks[cwString].container,
              sumTM = scansFilteredByWeeks[cwString].tm,
              sumTotal = scansFilteredByWeeks[cwString].sumTotal,
              sumCritical = scansFilteredByWeeks[cwString].sumCritical,
              sumHigh = scansFilteredByWeeks[cwString].sumHigh,
              sumMedium = scansFilteredByWeeks[cwString].sumMedium,
              sumLow = scansFilteredByWeeks[cwString].sumLow,
              sumInfo = scansFilteredByWeeks[cwString].sumInfo;
            // scansOfWeek = scansFilteredByWeeks[cwString].scans;

            scansOfCurrentWeek.forEach((scan) => {
              scan.dateStr = moment(scan.importTime).format(
                "MMMM Do YYYY hh:mm:ss",
              );
            });

            // render
            const source =
              document.getElementById("app-modal-template").innerHTML;
            const template = window.Handlebars.compile(source);
            const context = {
              appName,
              cwString,
              sumTotal,
              sumCritical,
              sumHigh,
              sumMedium,
              sumLow,
              sumInfo,
              sumTM,
              sumSast,
              sumContainer,
              scansOfCurrentWeek: scansOfCurrentWeek,
            };
            const html = template(context);
            dialogObject.open(html);

            let datesOfWeek = [];
            if (scansOfCurrentWeek.length) {
              const week = moment(scansOfCurrentWeek[0].importTime);
              const weekStart = week.clone().startOf("isoWeek");
              for (let i = 0; i < 7; i++) {
                datesOfWeek.push(
                  weekStart.clone().add(i, "days").format("YYYY-MM-DD"),
                );
              }
            }
            const seriesWeek = [
              {
                data: [],
              },
            ];
            for (const date of datesOfWeek) {
              const scansOnDay = scansOfCurrentWeek.filter((s) => {
                return (
                  moment(s.importTime).format("YYYY-MM-DD") ==
                  moment(date).format("YYYY-MM-DD")
                );
              });
              let numTotal = 0;
              scansOnDay.forEach((scan) => {
                numTotal += scan.numberTotalVulnerabilities;
              });
              seriesWeek[0].data.push({
                x: date,
                y: numTotal,
              });
            }

            let options = {
              chart: {
                type: "bar",
                height: 350,
              },
              series: seriesWeek,
              xaxis: {
                categories: datesOfWeek,
              },
              yaxis: {
                title: {
                  text: "Number of Vulnerabilities",
                },
              },
              tooltip: {
                y: {
                  formatter: function (val) {
                    return val + " vulnerabilities";
                  },
                },
              },
              plotOptions: {
                bar: {
                  horizontal: false,
                },
              },
              legend: {
                position: "top",
              },
              fill: {
                opacity: 1,
              },
            };
            const chart1 = new ApexCharts(
              document.querySelector("#chart-scans-of-week"),
              options,
            );
            chart1.render();
          },
        },
      },
      plotOptions: {
        heatmap: {
          enableShades: false,
          // shadeIntensity: 0,
          // reverseNegativeShade: true,
          radius: 0,
          useFillColorAsStroke: false,
          colorScale: colorScale,
        },
      },
      dataLabels: {
        enabled: false,
      },
      stroke: {
        width: 1,
      },
      title: {
        text: "",
      },
      // TODO: enabled: false makes click events break
      // because "seriesIndex" will be "-1" => WTF!?
      // tooltip: {
      //   enabled: false
      // }
    };

    CHART = new ApexCharts(document.querySelector("#heatmap"), options);
    CHART.render();
  }

  // do not fetch from server if already fetched
  if (APPS) {
    return renderChart();
  }

  fetchData().then((data) => {
    APPS = data;

    if (!APPS) {
      setLoading("");
      console.error("DATA", data);
      throw new Error("No data fetched from server, exit.");
    }

    if (APPS.length === 0) {
      setLoading("");
      console.log("DATA empty", data);
      return;
    }

    renderChart();
  });

  function generateData(app) {
    // everytime before we re-render we filter ALL scans
    const scans = filterScansByScannerType(app.scans, formProps.scanner);

    const scansFilteredByWeeks = normalizeScansForHistoricalView(
      scans,
      formProps.start_date,
      formProps.end_date,
    );

    const series = [];
    for (const calendarWeek of calendarWeeks) {
      let y = 0;
      const weekStr = "CW" + calendarWeek.week + " " + calendarWeek.year;

      // scansFilteredByWeeks is sometimes not filled at the current CW, so just ignore it
      if (!scansFilteredByWeeks[weekStr]) {
        continue;
      }
      const scansOfCurrentWeek = scansFilteredByWeeks[weekStr].scans;
      const latestScansPerTypeInThisWeek =
        scansFilteredByWeeks[weekStr].latestScansPerTypeInThisWeek;

      // Generate sum of all findings of the current week and calculate weighted average
      let sumCritical = scansFilteredByWeeks[weekStr].sumCritical,
        sumHigh = scansFilteredByWeeks[weekStr].sumHigh,
        sumMedium = scansFilteredByWeeks[weekStr].sumMedium,
        sumLow = scansFilteredByWeeks[weekStr].sumLow,
        sumInfo = scansFilteredByWeeks[weekStr].sumInfo,
        sumTotalVulnerabilities = scansFilteredByWeeks[weekStr].sumTotal;

      // for (const scanOfCurrentWeek of scansOfCurrentWeek) {
      //   sumCritical += scanOfCurrentWeek.numberCriticalVulnerabilities;
      //   sumHigh += scanOfCurrentWeek.numberHighVulnerabilities;
      //   sumMedium += scanOfCurrentWeek.numberMediumVulnerabilities;
      //   sumLow += scanOfCurrentWeek.numberLowVulnerabilities;
      //   sumInfo += scanOfCurrentWeek.numberInfoVulnerabilities;
      //   sumTotalVulnerabilities += scanOfCurrentWeek.numberTotalVulnerabilities;
      // }

      let weighted_average;

      if (sumTotalVulnerabilities > 0) {
        weighted_average =
          (sumCritical * factorCritical +
            sumHigh * factorHigh +
            sumMedium * factorMedium +
            sumLow * factorLow +
            sumInfo * factorInfo) /
          sumTotalVulnerabilities;

        y = weighted_average;
        // console.log("Average value", y);
      }

      // what to do if there is no scan in a week?
      if (scansOfCurrentWeek.length === 0) {
        y = 5.1;
      }

      // TODO2: WANN wird denn "sla_days_remaining" berechnet? müssen wir das ggf machen? also einfach im FE anhand create date?
      if (scenarioSelect.value === "sla") {
        y = calculateSLAColorForWeek(weekStr, latestScansPerTypeInThisWeek);
      }

      series.push({
        x: weekStr,
        y: y,
      });
    }

    return series;
  }
}
