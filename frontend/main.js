/**
 * Main file for the frontend
 *
 * TODO: maybe use a framework for structuring...?
 */
import moment from "moment";
import { logToUI, getScansOfCalendarWeek } from "./helpers.js";

if (document) {
  if (!document.getElementById("start_date").value) {
    document.getElementById("start_date").value = moment()
      .subtract(3, "months")
      .toISOString()
      .substr(0, 10);
  }
  if (!document.getElementById("end_date").value) {
    document.getElementById("end_date").value = new Date()
      .toISOString()
      .substr(0, 10);
  }
}
let CHART;
const logElement = document.getElementById("log");
logToUI(logElement, "logs...");
let API_URL;
let formProps;
const form = document.getElementById("form");
form.addEventListener("submit", (event) => {
  event.preventDefault();

  API_URL = "http://" + window.location.host + "/api"; // http://10.109.64.133:9876/

  const formData = new FormData(event.target);
  formProps = Object.fromEntries(formData);

  // TODO: select which tool in the UI?
  API_URL +=
    "/kiuwan?appName=" +
    formProps.search +
    "&startDate=" +
    moment(formProps.start_date).unix() * 1000 +
    "&endDate=" +
    moment(formProps.end_date).unix() * 1000;

  console.log("init with form data ", formProps);
  initHeatmap();
});

function setLoading(loading) {
  document.querySelector("#heatmap").innerHTML = loading;
}
function initHeatmap() {
  if (CHART) {
    CHART.destroy();
  }
  setLoading("loading...");

  // Fetch data from the node.js server, returns a promise with json data
  function fetchData() {
    // test env means GitHub pages, no backend needed there
    if (NODE_ENV == "test") {
      return fetch(
        "/VulnerabilityHeatmap/backend/adapters/threadfix_response.json"
      )
        .then((r) => r.json())
        .then((json) => json.object);
    }

    return fetch(API_URL, {
      method: "GET",
    }).then(
      function (response) {
        return response.json();
      },
      function (error) {
        console.log("ERRORRRRRRRRRRR", error.message); // => String
      }
    );
  }

  // generate calendar weeks from start_date to end_date
  const calendarWeeks = [
    {
      week: moment(formProps.start_date).week(),
      year: moment(formProps.start_date).year(),
    },
  ];

  let timestamp = moment(formProps.start_date).unix();
  const lastTimestamp = moment(formProps.endDate).unix();
  let weeksToAdd = 1;
  while (timestamp <= lastTimestamp) {
    const date = moment(formProps.start_date).add(weeksToAdd, "weeks");
    timestamp = date.unix();
    weeksToAdd++;

    calendarWeeks.push({
      week: date.week(),
      year: date.year(),
    });
  }
  console.log(
    "Calendar weeks between ",
    moment(formProps.start_date).week(),
    moment(formProps.end_date).week(),
    calendarWeeks
  );

  // function getSelectValues(select) {
  //   const result = [];
  //   const options = select && select.options;
  //   let opt;

  //   for (let i = 0, iLen = options.length; i < iLen; i++) {
  //     opt = options[i];

  //     if (opt.selected) {
  //       result.push((opt.value || opt.text).toLowerCase());
  //     }
  //   }
  //   return result;
  // }

  fetchData().then(function (data) {
    setLoading("");
    console.log("DATA FROM SERVER", data);
    const APPS = data;

    if (!APPS) {
      console.error("DATA", data);
      logToUI(logElement, "ERROR: no data from server");
      throw new Error("No data fetched from server, exit.");
    }

    const series = [];

    let i = 0;
    for (const app of APPS) {
      if (app.name.indexOf(formProps.search) > -1) {
        console.log("app: ", app, "# scans = " + app.scans.length);

        series.push({
          name: app.name,
          data: generateData(app),
        });
      }
      // TODO: how many (which) apps?
      if (++i > 20) break;
    }

    const options = {
      series: series,
      chart: {
        height: "100%", // https://apexcharts.com/docs/options/chart/height/
        type: "heatmap",
        events: {
          click: function (event, chartContext, config) {
            // The last parameter config contains additional information like `seriesIndex` and `dataPointIndex` for cartesian charts

            console.log(event, chartContext, config);
          },
        },
      },
      plotOptions: {
        heatmap: {
          shadeIntensity: 0.5,
          radius: 0,
          useFillColorAsStroke: true,
          colorScale: {
            ranges: [
              {
                from: 0,
                to: 5,
                name: "low",
                color: "#00A100",
              },
              {
                from: 6,
                to: 10,
                name: "medium",
                color: "#128FD9",
              },
              {
                from: 11,
                to: 20,
                name: "high",
                color: "#FFB200",
              },
              {
                from: 21,
                to: 1000000000000, // >
                name: "extreme",
                color: "#FF0000",
              },
            ],
          },
        },
      },
      dataLabels: {
        enabled: false,
      },
      stroke: {
        width: 1,
      },
      title: {
        text: "HeatMap Chart with Color Range",
      },
    };

    CHART = new ApexCharts(document.querySelector("#heatmap"), options);
    CHART.render();

    /*
      console.log("verteilung", series);
      let options = {
        series: series, // array for the data
        chart: {
          //height: 350,
          type: "heatmap",
        },
        dataLabels: {
          formatter: function (val, opts) {
            // TODO. this is wrong!

            //console.log(val, opts)
            const seriesValue = series[opts.seriesIndex];
            // const dataOfSeriesValue = seriesValue.data[opts.dataPointIndex]
            const app = APPS.find((app) => {
              return app.uniqueId === seriesValue.id;
            });
            //console.log("YES",seriesValue.name,  app)
            // TODO: no sense. discuss reqs with team and fix this "scans" issue
            // const scan = app.scans[opts.dataPointIndex] // TODO. WTF? :D
            return [
              " TODO",
              //'Critical: ' + scan.numberCriticalVulnerabilities + ' High: ' + scan.numberHighVulnerabilities,
              //'Medium: ' + scan.numberMediumVulnerabilities + ' Low: ' + scan.numberLowVulnerabilities,
            ];
          },
          //offsetY: -15,
          style: {
            fontSize: "8px",
          },
        },
        plotOptions: {
          heatmap: {
            shadeIntensity: 0.5,
            radius: 0,
            useFillColorAsStroke: true,
            // https://apexcharts.com/react-chart-demos/heatmap-charts/color-range/
            // TODO
            // /*Following colors should be applied (depending on definied threshholds):
            //     Blue (no information available) #002dee
            //     Light Green (weighted_criticality < th1) 0df31e
            //     Dark Green (th1 < weighted_criticality < th2) 008000
            //     Yellow (th2 < weighted_criticality < th3) FFFF00
            //     Orange  (th3 < weighted_criticality < th4) FF7F00
            //     Red (th4 < weighted_criticality < th5)  FF0000
            //     Dark-Red (th5 < weighted_criticality) a71a17
            //      * /
            // REQ: The fields of the heat map should be colored depending on the defined thresholds for application vulnerabilities.

            colorScale: {
              ranges: [
                {
                  from: verteilung[0][0],
                  to: verteilung[0][1],
                  name: "none",
                  color: "#002dee", // blue
                },
                {
                  from: verteilung[1][0],
                  to: verteilung[1][1],
                  name: "info",
                  color: "#0df31e", // Light Green
                },
                {
                  from: verteilung[2][0],
                  to: verteilung[2][1],
                  name: "low",
                  color: "#008000", // Dark Green
                },
                {
                  from: verteilung[3][0],
                  to: verteilung[3][1],
                  name: "med",
                  color: "#FFFF00", // yellow
                },
                {
                  from: verteilung[4][0],
                  to: verteilung[4][1],
                  name: "high",
                  color: "#FF7F00", // orange
                },
                {
                  from: verteilung[5][0],
                  to: verteilung[5][1],
                  name: "critical",
                  color: "#FF0000", // red
                },
                {
                  from: verteilung[6][0],
                  to: verteilung[6][1],
                  name: "very critical",
                  color: "#a71a17", // dark red
                },
              ],
            },
          },
        },
        // colors: [],
        title: {
          text: "Threadfix HeatMap Chart",
        },
      };

      var chart = new ApexCharts(document.querySelector("#heatmap"), options);
      chart.render();
      // /*chart.updateSeries([{
      //       name: 'Sales',
      //       data: response.data
      //   }])* /
      */
  });

  function generateData(app) {
    /* for (scan of app.scans) {
        console.log(moment(scan.importTime).week(), scan.importTime, new Date(scan.importTime))
      }*/

    const series = [];
    for (const calendarWeek of calendarWeeks) {
      // const selectedScanners = getSelectValues(
      //     document.getElementById('scanner'),
      // );

      const scansOfCurrentWeek = getScansOfCalendarWeek(
        app.scans,
        calendarWeek.week,
        calendarWeek.year
      );

      // TODO: implement scanner matching
      // if (selectedScanners[0] === 'all') {
      //  return weekFound;
      // } else {
      // // TODO: TEST THIS! ggf doch unit tests irgendwie? index.js und tests.js !
      // // selectedScanners = ['kiuwan', 'acunetix']
      // const scannerMatch = selectedScanners.find((scanner) => {
      // // console.log(scanner, scan.scannerName);
      //   return scan.scannerName.indexOf(scanner > -1);
      // });
      //   return weekFound && scannerMatch;
      // }

      // TODO: what to do if there is no scan in a week?
      console.log(
        "checking scans in CW ",
        calendarWeek,
        scansOfCurrentWeek.length
      );

      // Generate sum of all findings of the current week
      let y = 0;
      for (const scanOfCurrentWeek of scansOfCurrentWeek) {
        y += scanOfCurrentWeek.numberTotalVulnerabilities;
      }

      // if (scansOfCurrentWeek && scansOfCurrentWeek.length) {
      //   let scan = scansOfCurrentWeek[scansOfCurrentWeek.length - 1];
      //   const info = scan.numberInfoVulnerabilities;
      //   const low = scan.numberLowVulnerabilities;
      //   const med = scan.numberMediumVulnerabilities;
      //   const high = scan.numberHighVulnerabilities;
      //   const critical = scan.numberCriticalVulnerabilities;
      //   const sumWeights = info + low + med + high + critical;
      //   // console.log(sumWeights); === scan.numberTotalVulnerabilities
      //   const avg =
      //     sumWeights === 0
      //       ? 0
      //       : (formProps.factor_info * info +
      //           formProps.factor_low * low +
      //           formProps.factor_medium * med +
      //           formProps.factor_high * high +
      //           formProps.factor_critical * critical) /
      //         sumWeights;

      //   // console.log("CALCULATION: ", info, low, med, high, critical, ' = ', avg);

      //   y = avg;
      // } else {
      //   y = 0;
      // }

      const x = "CW" + calendarWeek.week + " " + calendarWeek.year;
      series.push({
        x: x,
        y: y,
      });
    }

    return series;
  }
}
