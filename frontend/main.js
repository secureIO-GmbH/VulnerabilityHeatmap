/**
 * Main file for the frontend
 *
 * TODO: maybe use a framework for structuring...?
 */
import moment from "moment";
import {
  logToUI,
  filterScansOfWeek,
  dialogObject,
  normalizeScansForHistoricalView,
} from "./helpers.js";

if (document) {
  if (!document.getElementById("start_date").value) {
    document.getElementById("start_date").value = moment()
      .subtract(3, "months")
      .toISOString()
      .substr(0, 10);
  }
  if (!document.getElementById("end_date").value) {
    document.getElementById("end_date").value = new Date()
      .toISOString()
      .substr(0, 10);
  }

  document.getElementById("scenarioHelp").addEventListener("click", () => {
    let html = `<h3>Scenarios</h3>
      <p>There are different scenarios possible which change the way the colors are calculated.</p>

      <h5>Scenario: "Weighted average" (based on history)</h5>
      <p>A weighted average is calculated based on the amount and severities of the cumulative findings of all scans until a certain calendar week. Each severity gets assigned a score. This method ensures the heatmap reflects both the volume and the severity of vulnerabilities. Example:</p>
      <pre>
      factorCritical = 5,
      factorHigh  = 4,
      factorMedium = 3,
      factorLow = 2,
      factorInfo = 1;

      weighted_average =
        (sumCritical * factorCritical +
        sumHigh * factorHigh +
        sumMedium * factorMedium +
        sumLow * factorLow +
        sumInfo * factorInfo) / sumTotalVulnerabilities

      Based on this "weighted_average" value, the colors are calculated:

      0 to 1 (Very Low): Blue
      >1 to 2 (Low): Green
      >2 to 3 (Medium): Yellow
      >3 to 4 (High): Light Red
      >4 (Critical): Dark Red
      </pre>

      <p>To address the issue with the data display only per calendar week, a more accurate historical view of vulnerabilities for each scan type per calendar week, taking into account the findings from previous scans, a cumulative or rolling sum approach is implemented. This approach ensures that the current week's representation includes unresolved vulnerabilities from previous weeks, providing a more realistic view of the application's security posture over time.</p>
    `;
    html += "";
    dialogObject.open(html);
  });
}

const factorCritical = 5,
  factorHigh = 4,
  factorMedium = 3,
  factorLow = 2,
  factorInfo = 1;

let CHART;
const logElement = document.getElementById("log");
logToUI(logElement, "logs...");

let API_URL = "http://" + window.location.host + "/api/threadfix"; // http://10.109.64.133:9876/
let formProps;
const form = document.getElementById("form");

form.addEventListener("submit", (event) => {
  event.preventDefault();

  const formData = new FormData(event.target);
  formProps = Object.fromEntries(formData);

  // TODO: select which tool in the UI?
  // API_URL +=
  //   "kiuwan?appName=" +
  //   formProps.search +
  //   "&startDate=" +
  //   moment(formProps.start_date).unix() * 1000 +
  //   "&endDate=" +
  // 	moment(formProps.end_date).unix() * 1000;

  console.log("init with form data ", formProps);
  initHeatmap();
});

let APPS;

// Fetch data from the node.js server, returns a promise with json data
function fetchData() {
  // test env means GitHub pages, no backend needed there
  if (NODE_ENV == "test") {
    return fetch(
      "/VulnerabilityHeatmap/backend/adapters/threadfix_response.json",
    )
      .then((r) => r.json())
      .then((json) => json.object);
  }

  let url = API_URL;
  if (formProps.search) {
    url += `?appName=${formProps.search}`;
  }
  return fetch(url, {
    method: "GET",
  })
    .then(
      function (response) {
        return response.json();
      },
      function (error) {
        console.log("ERRORRRRRRRRRRR", error.message); // => String
      },
    )
    .catch((error) => {
      console.log("ERRORRRRRRRRRRR", error.message); // => String
    });
}

function setLoading(loading) {
  document.querySelector("#heatmap").innerHTML = loading;
}

function initHeatmap() {
  setLoading("loading...");

  if (CHART) {
    CHART.destroy();
  }
  // generate calendar weeks from start_date to end_date
  const calendarWeeks = [
    {
      week: moment(formProps.start_date).week(),
      year: moment(formProps.start_date).year(),
    },
  ];

  let timestamp = moment(formProps.start_date).unix();
  const lastTimestamp = moment(formProps.endDate).unix();

  let weeksToAdd = 1;
  while (timestamp <= lastTimestamp) {
    const date = moment(formProps.start_date).add(weeksToAdd, "weeks");
    timestamp = date.unix();
    weeksToAdd++;

    calendarWeeks.push({
      week: date.week(),
      year: date.year(),
    });
  }
  console.log(
    "Calendar weeks between ",
    moment(formProps.start_date).week(),
    moment(formProps.end_date).week(),
    calendarWeeks,
  );

  fetchData().then((data) => {
    APPS = data;

    setLoading("");

    if (!APPS) {
      console.error("DATA", data);
      logToUI(logElement, "ERROR: no data from server");
      throw new Error("No data fetched from server, exit.");
    }

    const series = [];

    // let i = 0;
    for (const app of APPS) {
      if (app.name.indexOf(formProps.search) > -1) {
        console.log("app: ", app, "# scans = " + app.scans.length);

        series.push({
          name: app.name,
          data: generateData(app),
        });
      }
      // TODO: how many (which) apps?
      // if (++i > 20) break;
    }

    const options = {
      series: series,
      chart: {
        height: "100%", // https://apexcharts.com/docs/options/chart/height/
        type: "heatmap",
        events: {
          /**
           * Clicking a box should display some information about the clicked calendar week
           * like how many scans, why is the color how it is etc
           *
           * TODO: fetch tf scan details by scanIds including CVEs, maybe fetch EPSS etc...
           */
          click: function (event, chartContext, config) {
            // The last parameter config contains additional information like `seriesIndex` and `dataPointIndex` for cartesian charts
            // console.log(event, chartContext, config);
            const appName = config.globals.seriesNames[config.seriesIndex];
            const cwString = config.globals.labels[config.dataPointIndex];
            let html = `<h3>Calendar Week: ${cwString}</h3>`;
            const appFound = APPS.find(function (app) {
              return app.name === appName;
            });

            const scansFilteredByWeeks = normalizeScansForHistoricalView(
              appFound.scans,
              formProps.start_date,
              formProps.end_date,
            );

            const scansOfCurrentWeek = scansFilteredByWeeks[cwString].scans;
            const scansOfCurrentWeekFiltered =
              filterScansOfWeek(scansOfCurrentWeek);

            html += `<p>Amount of scans in this week: ${scansOfCurrentWeekFiltered.length}</p>`;

            let sumSast = scansFilteredByWeeks[cwString].sast,
              sumContainer = scansFilteredByWeeks[cwString].container,
              sumTotal = scansFilteredByWeeks[cwString].sumTotal,
              sumCritical = scansFilteredByWeeks[cwString].sumCritical,
              sumHigh = scansFilteredByWeeks[cwString].sumHigh,
              sumMedium = scansFilteredByWeeks[cwString].sumMedium,
              sumLow = scansFilteredByWeeks[cwString].sumLow,
              sumInfo = scansFilteredByWeeks[cwString].sumInfo;

            html += `<p>History based sum of findings:
            <br>Sum total: ${sumTotal}
            <br>Sum critical: ${sumCritical}
            <br>Sum high: ${sumHigh}
            <br>Sum medium: ${sumMedium}
            <br>Sum low: ${sumLow}
            <br>Sum info: ${sumInfo}
            <br> Sum SAST: ${sumSast}
            <br> Sum Container: ${sumContainer}
            </p>`;

            html += `<p>All scans: </p>`;
            for (const scan of scansOfCurrentWeekFiltered) {
              html += `Scan from ${moment(scan.importTime).format(
                "MMMM Do YYYY",
              )} of type <b>${scan.scannerName}</b> has ${
                scan.numberTotalVulnerabilities
              } findings</br>`;
            }

            if (scansOfCurrentWeekFiltered.length === 0) {
              html += `<p style="color:red">No scan at all happened in this week!</p>`;
            }

            dialogObject.open(html);
          },
        },
      },
      plotOptions: {
        heatmap: {
          shadeIntensity: 0.5,
          radius: 0,
          useFillColorAsStroke: true,
          colorScale: {
            ranges: [
              {
                from: 0,
                to: 0.9,
                name: "info",
                color: "#5a80b8",
              },
              {
                from: 1,
                to: 1.9,
                name: "low",
                color: "#00A100",
              },
              {
                from: 2,
                to: 2.9,
                name: "medium",
                color: "#fbfe36",
              },
              {
                from: 3,
                to: 3.9,
                name: "high",
                color: "#d45c1f",
              },
              {
                from: 4,
                to: 1000000000000, // >
                name: "extreme",
                color: "#FF0000",
              },
            ],
          },
        },
      },
      dataLabels: {
        enabled: false,
      },
      stroke: {
        width: 1,
      },
      title: {
        text: "HeatMap Chart with Color Range",
      },
    };

    CHART = new ApexCharts(document.querySelector("#heatmap"), options);
    CHART.render();
  });

  function generateData(app) {
    const scansFilteredByWeeks = normalizeScansForHistoricalView(
      app.scans,
      formProps.start_date,
      formProps.end_date,
    );

    const series = [];
    for (const calendarWeek of calendarWeeks) {
      let y = 0;
      const weekStr = "CW" + calendarWeek.week + " " + calendarWeek.year;
      const scansOfCurrentWeek = scansFilteredByWeeks[weekStr].scans;
      const scansOfCurrentWeekFiltered = filterScansOfWeek(scansOfCurrentWeek);

      // Generate sum of all findings of the current week and calculate weighted average
      let sumCritical = scansFilteredByWeeks[weekStr].sumCritical,
        sumHigh = scansFilteredByWeeks[weekStr].sumHigh,
        sumMedium = scansFilteredByWeeks[weekStr].sumMedium,
        sumLow = scansFilteredByWeeks[weekStr].sumLow,
        sumInfo = scansFilteredByWeeks[weekStr].sumInfo,
        sumTotalVulnerabilities = scansFilteredByWeeks[weekStr].sumTotal;

      // for (const scanOfCurrentWeek of scansOfCurrentWeekFiltered) {
      //   sumCritical += scanOfCurrentWeek.numberCriticalVulnerabilities;
      //   sumHigh += scanOfCurrentWeek.numberHighVulnerabilities;
      //   sumMedium += scanOfCurrentWeek.numberMediumVulnerabilities;
      //   sumLow += scanOfCurrentWeek.numberLowVulnerabilities;
      //   sumInfo += scanOfCurrentWeek.numberInfoVulnerabilities;
      //   sumTotalVulnerabilities += scanOfCurrentWeek.numberTotalVulnerabilities;
      // }

      let weighted_average;

      if (sumTotalVulnerabilities > 0) {
        weighted_average =
          (sumCritical * factorCritical +
            sumHigh * factorHigh +
            sumMedium * factorMedium +
            sumLow * factorLow +
            sumInfo * factorInfo) /
          sumTotalVulnerabilities;

        y = weighted_average;
        console.log("Average value", y);
      }

      // what to do if there is no scan in a week? -> DARK RED!
      if (scansOfCurrentWeekFiltered.length === 0) {
        y = 100000000;
      }

      series.push({
        x: weekStr,
        y: y,
      });
    }

    return series;
  }
}
