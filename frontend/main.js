/**
 * Main file for the frontend
 *
 * TODO: maybe use a framework for structuring...?
 */
import moment from "moment";
import {
  logToUI,
  getScansOfCalendarWeek,
  filterScansOfWeek,
  dialogObject,
} from "./helpers.js";

if (document) {
  if (!document.getElementById("start_date").value) {
    document.getElementById("start_date").value = moment()
      .subtract(3, "months")
      .toISOString()
      .substr(0, 10);
  }
  if (!document.getElementById("end_date").value) {
    document.getElementById("end_date").value = new Date()
      .toISOString()
      .substr(0, 10);
  }
}

const factorCritical = 40,
  factorHigh = 20,
  factorMedium = 3,
  factorLow = 2,
  factorInfo = 1;

let CHART;
const logElement = document.getElementById("log");
logToUI(logElement, "logs...");

let API_URL = "http://" + window.location.host + "/api/threadfix"; // http://10.109.64.133:9876/
let formProps;
const form = document.getElementById("form");

form.addEventListener("submit", (event) => {
  event.preventDefault();

  const formData = new FormData(event.target);
  formProps = Object.fromEntries(formData);

  // TODO: select which tool in the UI?
  // API_URL +=
  //   "kiuwan?appName=" +
  //   formProps.search +
  //   "&startDate=" +
  //   moment(formProps.start_date).unix() * 1000 +
  //   "&endDate=" +
  // 	moment(formProps.end_date).unix() * 1000;

  console.log("init with form data ", formProps);
  initHeatmap();
});

const appSelectEl = document.getElementById("application");
let options = '<option value="">Select application</option>';
fetchData().then(function (data) {
  for (const app of data) {
    options += `<option value="${app.name}">${app.name}</option>`;
  }
  document.getElementById("application").innerHTML = options;
});

appSelectEl.addEventListener("change", function () {
  const formData = new FormData(form);
  formProps = Object.fromEntries(formData);
  initHeatmap();
});

// Fetch data from the node.js server, returns a promise with json data
function fetchData() {
  // test env means GitHub pages, no backend needed there
  if (NODE_ENV == "test") {
    return fetch(
      "/VulnerabilityHeatmap/backend/adapters/threadfix_response.json",
    )
      .then((r) => r.json())
      .then((json) => json.object);
  }

  return fetch(API_URL, {
    method: "GET",
  }).then(
    function (response) {
      return response.json();
    },
    function (error) {
      console.log("ERRORRRRRRRRRRR", error.message); // => String
    },
  );
}

function setLoading(loading) {
  document.querySelector("#heatmap").innerHTML = loading;
}

function initHeatmap() {
  if (!appSelectEl.value) {
    return;
  }

  if (CHART) {
    CHART.destroy();
  }
  setLoading("loading...");

  // generate calendar weeks from start_date to end_date
  const calendarWeeks = [
    {
      week: moment(formProps.start_date).week(),
      year: moment(formProps.start_date).year(),
    },
  ];

  let timestamp = moment(formProps.start_date).unix();
  const lastTimestamp = moment(formProps.endDate).unix();
  let weeksToAdd = 1;
  while (timestamp <= lastTimestamp) {
    const date = moment(formProps.start_date).add(weeksToAdd, "weeks");
    timestamp = date.unix();
    weeksToAdd++;

    calendarWeeks.push({
      week: date.week(),
      year: date.year(),
    });
  }
  console.log(
    "Calendar weeks between ",
    moment(formProps.start_date).week(),
    moment(formProps.end_date).week(),
    calendarWeeks,
  );

  fetchData().then(function (data) {
    setLoading("");
    console.log("DATA FROM SERVER", data);
    const APPS = data;

    if (!APPS) {
      console.error("DATA", data);
      logToUI(logElement, "ERROR: no data from server");
      throw new Error("No data fetched from server, exit.");
    }

    const series = [];

    // let i = 0;
    for (const app of APPS) {
      // if (app.name.indexOf(formProps.search) > -1) {
      if (app.name === appSelectEl.value) {
        console.log("app: ", app, "# scans = " + app.scans.length);

        series.push({
          name: app.name,
          data: generateData(app),
        });
      }
      // TODO: how many (which) apps?
      // if (++i > 20) break;
    }

    const options = {
      series: series,
      chart: {
        height: "100%", // https://apexcharts.com/docs/options/chart/height/
        type: "heatmap",
        events: {
          /**
           * Clicking a box should display some information about the clicked calendar week
           * like how many scans, why is the color how it is etc
           */
          click: function (event, chartContext, config) {
            // The last parameter config contains additional information like `seriesIndex` and `dataPointIndex` for cartesian charts
            console.log(event, chartContext, config);

            const appName = config.globals.seriesNames[config.seriesIndex];
            const cwString = config.globals.labels[config.dataPointIndex];
            let html = `<h3>Calendar Week: ${cwString}</h3>`;
            const tmp = cwString.replace("CW", "").split(" ");
            const week = parseInt(tmp[0]);
            const year = parseInt(tmp[1]);
            const appFound = APPS.find(function (app) {
              return app.name === appName;
            });

            const scansOfCurrentWeek = getScansOfCalendarWeek(
              appFound.scans,
              week,
              year,
            );
            const scansOfCurrentWeekFiltered =
              filterScansOfWeek(scansOfCurrentWeek);

            html += `<p>Amount of scans in this week: ${scansOfCurrentWeekFiltered.length}</p>`;

            for (const scan of scansOfCurrentWeekFiltered) {
              html += JSON.stringify(scan) + "</br>";
            }

            dialogObject.open(html);
          },
        },
      },
      plotOptions: {
        heatmap: {
          shadeIntensity: 0.5,
          radius: 0,
          useFillColorAsStroke: true,
          colorScale: {
            ranges: [
              {
                from: 0,
                to: 5,
                name: "info",
                color: "#5a80b8",
              },
              {
                from: 6,
                to: 10,
                name: "low",
                color: "#00A100",
              },
              {
                from: 11,
                to: 20,
                name: "medium",
                color: "#128FD9",
              },
              {
                from: 21,
                to: 50,
                name: "high",
                color: "#FFB200",
              },
              {
                from: 51,
                to: 1000000000000, // >
                name: "extreme",
                color: "#FF0000",
              },
            ],
          },
        },
      },
      dataLabels: {
        enabled: false,
      },
      stroke: {
        width: 1,
      },
      title: {
        text: "HeatMap Chart with Color Range",
      },
    };

    CHART = new ApexCharts(document.querySelector("#heatmap"), options);
    CHART.render();

    /*
      console.log("verteilung", series);
      let options = {
        series: series, // array for the data
        chart: {
          //height: 350,
          type: "heatmap",
        },
        dataLabels: {
          formatter: function (val, opts) {
            // TODO. this is wrong!

            //console.log(val, opts)
            const seriesValue = series[opts.seriesIndex];
            // const dataOfSeriesValue = seriesValue.data[opts.dataPointIndex]
            const app = APPS.find((app) => {
              return app.uniqueId === seriesValue.id;
            });
            //console.log("YES",seriesValue.name,  app)
            // TODO: no sense. discuss reqs with team and fix this "scans" issue
            // const scan = app.scans[opts.dataPointIndex] // TODO. WTF? :D
            return [
              " TODO",
              //'Critical: ' + scan.numberCriticalVulnerabilities + ' High: ' + scan.numberHighVulnerabilities,
              //'Medium: ' + scan.numberMediumVulnerabilities + ' Low: ' + scan.numberLowVulnerabilities,
            ];
          },
          //offsetY: -15,
          style: {
            fontSize: "8px",
          },
        },
        plotOptions: {
          heatmap: {
            shadeIntensity: 0.5,
            radius: 0,
            useFillColorAsStroke: true,
            // https://apexcharts.com/react-chart-demos/heatmap-charts/color-range/
            // TODO
            // /*Following colors should be applied (depending on definied threshholds):
            //     Blue (no information available) #002dee
            //     Light Green (weighted_criticality < th1) 0df31e
            //     Dark Green (th1 < weighted_criticality < th2) 008000
            //     Yellow (th2 < weighted_criticality < th3) FFFF00
            //     Orange  (th3 < weighted_criticality < th4) FF7F00
            //     Red (th4 < weighted_criticality < th5)  FF0000
            //     Dark-Red (th5 < weighted_criticality) a71a17
            //      * /
            // REQ: The fields of the heat map should be colored depending on the defined thresholds for application vulnerabilities.

            colorScale: {
              ranges: [
                {
                  from: verteilung[0][0],
                  to: verteilung[0][1],
                  name: "none",
                  color: "#002dee", // blue
                },
                {
                  from: verteilung[1][0],
                  to: verteilung[1][1],
                  name: "info",
                  color: "#0df31e", // Light Green
                },
                {
                  from: verteilung[2][0],
                  to: verteilung[2][1],
                  name: "low",
                  color: "#008000", // Dark Green
                },
                {
                  from: verteilung[3][0],
                  to: verteilung[3][1],
                  name: "med",
                  color: "#FFFF00", // yellow
                },
                {
                  from: verteilung[4][0],
                  to: verteilung[4][1],
                  name: "high",
                  color: "#FF7F00", // orange
                },
                {
                  from: verteilung[5][0],
                  to: verteilung[5][1],
                  name: "critical",
                  color: "#FF0000", // red
                },
                {
                  from: verteilung[6][0],
                  to: verteilung[6][1],
                  name: "very critical",
                  color: "#a71a17", // dark red
                },
              ],
            },
          },
        },
        // colors: [],
        title: {
          text: "Threadfix HeatMap Chart",
        },
      };

      var chart = new ApexCharts(document.querySelector("#heatmap"), options);
      chart.render();
      // /*chart.updateSeries([{
      //       name: 'Sales',
      //       data: response.data
      //   }])* /
      */
  });

  function generateData(app) {
    /* for (scan of app.scans) {
        console.log(moment(scan.importTime).week(), scan.importTime, new Date(scan.importTime))
      }*/

    const series = [];
    for (const calendarWeek of calendarWeeks) {
      // const selectedScanners = getSelectValues(
      //     document.getElementById('scanner'),
      // );

      const scansOfCurrentWeek = getScansOfCalendarWeek(
        app.scans,
        calendarWeek.week,
        calendarWeek.year,
      );

      // TODO: implement scanner matching
      // if (selectedScanners[0] === 'all') {
      //  return weekFound;
      // } else {
      // // TODO: TEST THIS! ggf doch unit tests irgendwie? index.js und tests.js !
      // // selectedScanners = ['kiuwan', 'acunetix']
      // const scannerMatch = selectedScanners.find((scanner) => {
      // // console.log(scanner, scan.scannerName);
      //   return scan.scannerName.indexOf(scanner > -1);
      // });
      //   return weekFound && scannerMatch;
      // }

      console.log(
        "checking scans in CW ",
        calendarWeek,
        scansOfCurrentWeek.length,
      );

      let y = 0;
      const scansOfCurrentWeekFiltered = filterScansOfWeek(scansOfCurrentWeek);

      // what to do if there is no scan in a week? -> DARK RED!
      if (scansOfCurrentWeekFiltered.length === 0) {
        y = 100000000;
      }

      // if (calendarWeek.week == 40 && calendarWeek.year == 2023) {
      //   console.log("YYYYYYYYYY", scansOfCurrentWeekFiltered.length);
      // }

      // Generate sum of all findings of the current week and calculate weighted average
      let sumCritical = 0,
        sumHigh = 0,
        sumMedium = 0,
        sumLow = 0,
        sumInfo = 0;

      for (const scanOfCurrentWeek of scansOfCurrentWeekFiltered) {
        /* TODO?
				numberClosedVulnerabilities: 0
				numberCriticalVulnerabilities: 0
				numberHighVulnerabilities: 0
				numberInfoVulnerabilities: 0
				numberLowVulnerabilities: 0
				numberMediumVulnerabilities: 0
				numberNewVulnerabilities: 0
				numberOldVulnerabilities: 0
				numberRepeatFindings: 0
				numberRepeatResults: 0
				numberResurfacedVulnerabilities: 0
				numberTotalVulnerabilities: 0
				numberUnassignedVulnerabilities: 0
				*/

        sumCritical += scanOfCurrentWeek.numberCriticalVulnerabilities;
        sumHigh += scanOfCurrentWeek.numberHighVulnerabilities;
        sumMedium += scanOfCurrentWeek.numberMediumVulnerabilities;
        sumLow += scanOfCurrentWeek.numberLowVulnerabilities;
        sumInfo += scanOfCurrentWeek.numberInfoVulnerabilities;
      }

      const weighted_average =
        sumCritical * factorCritical +
        sumHigh * factorHigh +
        sumMedium * factorMedium +
        sumLow * factorLow +
        sumInfo * factorInfo;

      y = weighted_average;

      const x = "CW" + calendarWeek.week + " " + calendarWeek.year;
      series.push({
        x: x,
        y: y,
      });
    }

    return series;
  }
}
