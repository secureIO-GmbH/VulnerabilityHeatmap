/**
 * Main file for the frontend
 *
 * TODO: maybe use a framework for structuring...?
 */
import moment from "moment";
import {
  logToUI,
  getScansOfCalendarWeek,
  filterScansOfWeek,
  dialogObject,
} from "./helpers.js";

if (document) {
  if (!document.getElementById("start_date").value) {
    document.getElementById("start_date").value = moment()
      .subtract(3, "months")
      .toISOString()
      .substr(0, 10);
  }
  if (!document.getElementById("end_date").value) {
    document.getElementById("end_date").value = new Date()
      .toISOString()
      .substr(0, 10);
  }
}

const factorCritical = 40,
  factorHigh = 20,
  factorMedium = 3,
  factorLow = 2,
  factorInfo = 1;

let CHART;
const logElement = document.getElementById("log");
logToUI(logElement, "logs...");

let API_URL = "http://" + window.location.host + "/api/threadfix"; // http://10.109.64.133:9876/
let formProps;
const form = document.getElementById("form");

form.addEventListener("submit", (event) => {
  event.preventDefault();

  const formData = new FormData(event.target);
  formProps = Object.fromEntries(formData);

  // TODO: select which tool in the UI?
  // API_URL +=
  //   "kiuwan?appName=" +
  //   formProps.search +
  //   "&startDate=" +
  //   moment(formProps.start_date).unix() * 1000 +
  //   "&endDate=" +
  // 	moment(formProps.end_date).unix() * 1000;

  console.log("init with form data ", formProps);
  initHeatmap();
});

let APPS;

// Fetch data from the node.js server, returns a promise with json data
function fetchData() {
  // test env means GitHub pages, no backend needed there
  if (NODE_ENV == "test") {
    return fetch(
      "/VulnerabilityHeatmap/backend/adapters/threadfix_response.json",
    )
      .then((r) => r.json())
      .then((json) => json.object);
  }

  let url = API_URL
  if (formProps.search) {
    url += `?appName=${formProps.search}`
  }
  return fetch(url, {
    method: "GET",
  }).then(
    function (response) {
      return response.json();
    },
    function (error) {
      console.log("ERRORRRRRRRRRRR", error.message); // => String
    },
  ).catch(error => {
    console.log("ERRORRRRRRRRRRR", error.message); // => String
  })
}

function setLoading(loading) {
  document.querySelector("#heatmap").innerHTML = loading;
}

function initHeatmap() {
  setLoading('loading...')

  if (CHART) {
    CHART.destroy();
  }
  // generate calendar weeks from start_date to end_date
  const calendarWeeks = [
    {
      week: moment(formProps.start_date).week(),
      year: moment(formProps.start_date).year(),
    },
  ];

  let timestamp = moment(formProps.start_date).unix();
  const lastTimestamp = moment(formProps.endDate).unix();
  let weeksToAdd = 1;
  while (timestamp <= lastTimestamp) {
    const date = moment(formProps.start_date).add(weeksToAdd, "weeks");
    timestamp = date.unix();
    weeksToAdd++;

    calendarWeeks.push({
      week: date.week(),
      year: date.year(),
    });
  }
  console.log(
    "Calendar weeks between ",
    moment(formProps.start_date).week(),
    moment(formProps.end_date).week(),
    calendarWeeks,
  );

  fetchData().then((data) => {
    APPS = data;

    setLoading('')

    if (!APPS) {
      console.error("DATA", data);
      logToUI(logElement, "ERROR: no data from server");
      throw new Error("No data fetched from server, exit.");
    }

    const series = [];

    // let i = 0;
    for (const app of APPS) {
      if (app.name.indexOf(formProps.search) > -1) {
        console.log("app: ", app, "# scans = " + app.scans.length);

        series.push({
          name: app.name,
          data: generateData(app),
        });
      }
      // TODO: how many (which) apps?
      // if (++i > 20) break;
    }

    const options = {
      series: series,
      chart: {
        height: "100%", // https://apexcharts.com/docs/options/chart/height/
        type: "heatmap",
        events: {
          /**
           * Clicking a box should display some information about the clicked calendar week
           * like how many scans, why is the color how it is etc
           */
          click: function (event, chartContext, config) {
            // The last parameter config contains additional information like `seriesIndex` and `dataPointIndex` for cartesian charts
            console.log(event, chartContext, config);

            const appName = config.globals.seriesNames[config.seriesIndex];
            const cwString = config.globals.labels[config.dataPointIndex];
            let html = `<h3>Calendar Week: ${cwString}</h3>`;
            const tmp = cwString.replace("CW", "").split(" ");
            const week = parseInt(tmp[0]);
            const year = parseInt(tmp[1]);
            const appFound = APPS.find(function (app) {
              return app.name === appName;
            });

            const scansOfCurrentWeek = getScansOfCalendarWeek(
              appFound.scans,
              week,
              year,
            );
            const scansOfCurrentWeekFiltered =
              filterScansOfWeek(scansOfCurrentWeek);

            html += `<p>Amount of scans in this week: ${scansOfCurrentWeekFiltered.length}</p>`;

            for (const scan of scansOfCurrentWeekFiltered) {
              html += `Scan from ${moment(scan.importTime)} of type <b>${scan.scannerName}</b> has ${scan.numberTotalVulnerabilities} findings</br>`

              console.log(scan);
            }

            dialogObject.open(html);
          },
        },
      },
      plotOptions: {
        heatmap: {
          shadeIntensity: 0.5,
          radius: 0,
          useFillColorAsStroke: true,
          colorScale: {
            ranges: [
              {
                from: 0,
                to: 5,
                name: "info",
                color: "#5a80b8",
              },
              {
                from: 6,
                to: 10,
                name: "low",
                color: "#00A100",
              },
              {
                from: 11,
                to: 20,
                name: "medium",
                color: "#128FD9",
              },
              {
                from: 21,
                to: 500,
                name: "high",
                color: "#FFB200",
              },
              {
                from: 501,
                to: 1000000000000, // >
                name: "extreme",
                color: "#FF0000",
              },
            ],
          },
        },
      },
      dataLabels: {
        enabled: false,
      },
      stroke: {
        width: 1,
      },
      title: {
        text: "HeatMap Chart with Color Range",
      },
    };

    CHART = new ApexCharts(document.querySelector("#heatmap"), options);
    CHART.render();
  });

  function generateData(app) {
    /* for (scan of app.scans) {
        console.log(moment(scan.importTime).week(), scan.importTime, new Date(scan.importTime))
      }*/

    const series = [];
    for (const calendarWeek of calendarWeeks) {
      // const selectedScanners = getSelectValues(
      //     document.getElementById('scanner'),
      // );

      const scansOfCurrentWeek = getScansOfCalendarWeek(
        app.scans,
        calendarWeek.week,
        calendarWeek.year,
      );

      // TODO: implement scanner matching
      // if (selectedScanners[0] === 'all') {
      //  return weekFound;
      // } else {
      // // TODO: TEST THIS! ggf doch unit tests irgendwie? index.js und tests.js !
      // // selectedScanners = ['kiuwan', 'acunetix']
      // const scannerMatch = selectedScanners.find((scanner) => {
      // // console.log(scanner, scan.scannerName);
      //   return scan.scannerName.indexOf(scanner > -1);
      // });
      //   return weekFound && scannerMatch;
      // }

      console.log(
        "checking scans in CW ",
        calendarWeek,
        scansOfCurrentWeek.length,
      );

      let y = 0;
      const scansOfCurrentWeekFiltered = filterScansOfWeek(scansOfCurrentWeek);

      // what to do if there is no scan in a week? -> DARK RED!
      if (scansOfCurrentWeekFiltered.length === 0) {
        y = 100000000;
      }

      // if (calendarWeek.week == 40 && calendarWeek.year == 2023) {
      //   console.log("YYYYYYYYYY", scansOfCurrentWeekFiltered.length);
      // }

      // Generate sum of all findings of the current week and calculate weighted average
      let sumCritical = 0,
        sumHigh = 0,
        sumMedium = 0,
        sumLow = 0,
        sumInfo = 0;

      for (const scanOfCurrentWeek of scansOfCurrentWeekFiltered) {
        /* TODO?
				numberClosedVulnerabilities: 0
				numberCriticalVulnerabilities: 0
				numberHighVulnerabilities: 0
				numberInfoVulnerabilities: 0
				numberLowVulnerabilities: 0
				numberMediumVulnerabilities: 0
				numberNewVulnerabilities: 0
				numberOldVulnerabilities: 0
				numberRepeatFindings: 0
				numberRepeatResults: 0
				numberResurfacedVulnerabilities: 0
				numberTotalVulnerabilities: 0
				numberUnassignedVulnerabilities: 0
				*/

        sumCritical += scanOfCurrentWeek.numberCriticalVulnerabilities;
        sumHigh += scanOfCurrentWeek.numberHighVulnerabilities;
        sumMedium += scanOfCurrentWeek.numberMediumVulnerabilities;
        sumLow += scanOfCurrentWeek.numberLowVulnerabilities;
        sumInfo += scanOfCurrentWeek.numberInfoVulnerabilities;
      }

      const weighted_average =
        sumCritical * factorCritical +
        sumHigh * factorHigh +
        sumMedium * factorMedium +
        sumLow * factorLow +
        sumInfo * factorInfo;

      y = weighted_average;

      const x = "CW" + calendarWeek.week + " " + calendarWeek.year;
      series.push({
        x: x,
        y: y,
      });
    }

    return series;
  }
}
