/**
 * Main file for the frontend
 */
import moment from "moment";
import {
  COLOR_RANGE,
  logToUI,
  filterScansByScannerType,
  dialogObject,
  normalizeScansForHistoricalView,
  generateRandomDataForDemo,
  calculateSLAColorForWeek,
} from "./helpers.js";

// moment.locale('de');

if (document) {
  if (!document.getElementById("start_date").value) {
    document.getElementById("start_date").value = moment()
      .subtract(6, "months")
      .toISOString()
      .substr(0, 10);
  }
  if (!document.getElementById("end_date").value) {
    document.getElementById("end_date").value = new Date()
      .toISOString()
      .substr(0, 10);
  }

  document.getElementById("scenarioHelp").addEventListener("click", (event) => {
    event.preventDefault();
    let html = `<h3>Scenarios</h3>
      <p>There are different scenarios possible which change the way the colors are calculated.</p>

      <h5>Scenario: "Weighted average" (based on history)</h5>
      <p>A weighted average is calculated based on the amount and severities of the cumulative findings of all scans until a certain calendar week. Each severity gets assigned a score. This method ensures the heatmap reflects both the volume and the severity of vulnerabilities. Example:</p>
      <pre>
      factorCritical = 5,
      factorHigh  = 4,
      factorMedium = 3,
      factorLow = 2,
      factorInfo = 1;

      weighted_average =
        (sumCritical * factorCritical +
        sumHigh * factorHigh +
        sumMedium * factorMedium +
        sumLow * factorLow +
        sumInfo * factorInfo) / sumTotalVulnerabilities

      Based on this "weighted_average" value, the colors are calculated:

      0 to 1 (Very Low): Green
      >1 to 2 (Low): light green
      >2 to 3 (Medium): Yellow
      >3 to 4 (High): Red
      >4 (Critical): Dark Red
      </pre>

      <p>To address the issue with the data display only per calendar week, a more accurate historical view of vulnerabilities for each scan type per calendar week, taking into account the findings from previous scans, a cumulative or rolling sum approach is implemented. This approach ensures that the current week's representation includes unresolved vulnerabilities from previous weeks, providing a more realistic view of the application's security posture over time.</p>

      <h5>Scenario: "SLA Violations" (TODO!!!)</h5>
      <p>We get scans of different types per calendar week (e.g. SAST/SCA or Container). Each of these scans have a number of findings, including a field "sla_expiration_date". Based on this field we will display different colors.</p>
      <pre>Example:
      - In time (30-10 days to SLA) -> green
      - Prewarning (10 days to SLA) -> light green
      - Prewarning (5 days to SLA) -> yellow
      - Past SLA -> red
      - More than 5 days past SLA -> dark red
      </pre>
      <p>It is important to understand that we always take the historical, cumulative approach, i.e. in a certain CW we only check the *latest* scan of a scanner type. This latest scan now may have findings which violate the SLA and findings which do not violate it.</p>
    `;
    html += "";
    dialogObject.open(html);
  });
}

const factorCritical = 5,
  factorHigh = 4,
  factorMedium = 3,
  factorLow = 2,
  factorInfo = 1;

let CHART;
const logElement = document.getElementById("log");
logToUI(logElement, "logs...");

let API_URL = "https://" + window.location.host + "/api/dd";
let formProps, APPS;
const form = document.getElementById("form");
const selectScannerType = document.getElementById("scanner");
const scenarioSelect = document.getElementById("scenario");

form.addEventListener("submit", (event) => {
  event.preventDefault();

  const formData = new FormData(event.target);
  formProps = Object.fromEntries(formData);

  // TODO: select which tool in the UI?
  // API_URL +=
  //   "kiuwan?appName=" +
  //   formProps.search +
  //   "&startDate=" +
  //   moment(formProps.start_date).unix() * 1000 +
  //   "&endDate=" +
  // 	moment(formProps.end_date).unix() * 1000;

  console.log("init with form data ", formProps);
  initHeatmap();
});

const dateFields = document.getElementsByClassName("date-field");
Array.from(dateFields).forEach((f) => {
  f.addEventListener("change", (event) => {
    event.preventDefault();

    const formData = new FormData(form);
    formProps = Object.fromEntries(formData);
    initHeatmap();
  });
});

selectScannerType.addEventListener("change", (event) => {
  event.preventDefault();

  const formData = new FormData(form);
  formProps = Object.fromEntries(formData);
  initHeatmap();
});

scenarioSelect.addEventListener("change", (event) => {
  event.preventDefault();

  const formData = new FormData(form);
  formProps = Object.fromEntries(formData);
  initHeatmap();
});

// Fetch data from the node.js server, returns a promise with json data
function fetchData() {
  // test env means GitHub pages, no backend needed there
  if (NODE_ENV === "test") {
    // TODO: use generateRandomDataForDemo
    return new Promise((resolve) => {
      resolve(generateRandomDataForDemo());
    });
  }

  let url = API_URL;
  // if (formProps.search) {
  //   url += `?appName=${formProps.search}`;
  // }
  return fetch(url, {
    method: "GET",
  })
    .then(
      function (response) {
        return response.json();
      },
      function (error) {
        console.log("ERRORRRRRRRRRRR", error.message); // => String
      },
    )
    .catch((error) => {
      console.log("ERRORRRRRRRRRRR", error.message); // => String
    });
}

function setLoading(loading) {
  document.querySelector("#heatmap").innerHTML = loading;
  document.getElementById("lds-roller").style.display = loading
    ? "inline-block"
    : "none";
}

function initHeatmap() {
  if (CHART) {
    CHART.destroy();
  }
  setLoading("loading...");

  // generate calendar weeks from start_date to end_date
  const calendarWeeks = [
    {
      week: moment(formProps.start_date).week(),
      year: moment(formProps.start_date).year(),
    },
  ];

  let timestamp = moment(formProps.start_date).unix();
  const lastTimestamp = moment(formProps.endDate).unix();

  let weeksToAdd = 1;
  while (timestamp <= lastTimestamp) {
    const date = moment(formProps.start_date).add(weeksToAdd, "weeks");
    timestamp = date.unix();
    weeksToAdd++;

    calendarWeeks.push({
      week: date.week(),
      year: date.year(),
    });
  }
  console.log(
    "Calendar weeks between ",
    moment(formProps.start_date).week(),
    moment(formProps.end_date).week(),
    calendarWeeks,
  );

  function searchMatch(app) {
    return (
      formProps.search &&
      app.name.toLowerCase().indexOf(formProps.search.toLowerCase()) > -1
    );
  }

  function filteredApps() {
    return APPS.filter((app) => {
      if (!app.scans || app.scans.length === 0) {
        return false;
      }

      if (!formProps.tag && !formProps.search) {
        return true;
      }

      if (formProps.tag) {
        for (const tag of app.tags) {
          if (
            tag.name.toLowerCase().indexOf(formProps.tag.toLowerCase()) > -1
          ) {
            console.log("Matched tag: ", tag);
            if (searchMatch(app)) {
              return true;
            } else if (!formProps.search) {
              return true;
            }
          }
        }
      } else if (searchMatch(app)) {
        return true;
      } else if (!formProps.search) {
        return true;
      }
    });
  }

  function renderChart() {
    setLoading("");

    const appsFiltered = filteredApps();
    const series = [];

    for (const app of appsFiltered) {
      series.push({
        name: app.name,
        data: generateData(app),
      });
    }

    let height = appsFiltered.length * 70 + "px";
    if (appsFiltered.length <= 3) {
      height = "300px";
    }

    const colorScale = {
      ranges: [
        {
          from: 0,
          to: 0.9,
          name: "info",
          color: COLOR_RANGE.info, // green
        },
        {
          from: 0.901,
          to: 1.9,
          name: "low",
          color: COLOR_RANGE.low, // light green
        },
        {
          from: 1.901,
          to: 2.9,
          name: "medium",
          color: COLOR_RANGE.medium, // yellow
        },
        {
          from: 2.901,
          to: 3.9,
          name: "high",
          color: COLOR_RANGE.high, // red
        },
        {
          from: 3.901,
          to: 5, // >
          name: "critical",
          color: COLOR_RANGE.critical, // dark red
        },
        {
          from: 5.01,
          to: 1000000000000, // >
          name: "no scans in week",
          color: "#808080",
        },
      ],
    };

    const options = {
      series: series,
      // will not be shown if there is only one app (row)
      legend: {
        show: true,
        position: "top",
      },
      chart: {
        // height: "2000px", // TODO somehow inteligent calculating here?
        height: height, // https://apexcharts.com/docs/options/chart/height/
        type: "heatmap",
        events: {
          /**
           * Clicking a box should display some information about the clicked calendar week
           * like how many scans, why is the color how it is etc
           *
           * TODO: fetch tf scan details by scanIds including CVEs, maybe fetch EPSS etc...
           */
          click: function (event, chartContext, config) {
            // The last parameter config contains additional information like `seriesIndex` and `dataPointIndex` for cartesian charts
            // console.log(event, chartContext, config);
            const appName = config.globals.seriesNames[config.seriesIndex];
            const cwString = config.globals.labels[config.dataPointIndex];
            let html = `<h3>Calendar Week: ${cwString}</h3>`;
            const appFound = APPS.find(function (app) {
              return app.name === appName;
            });

            const scansFilteredByWeeks = normalizeScansForHistoricalView(
              appFound.scans,
              formProps.start_date,
              formProps.end_date,
            );

            const scansOfCurrentWeek = scansFilteredByWeeks[cwString].scans;

            let sumSast = scansFilteredByWeeks[cwString].sast,
              sumContainer = scansFilteredByWeeks[cwString].container,
              sumTM = scansFilteredByWeeks[cwString].tm,
              sumTotal = scansFilteredByWeeks[cwString].sumTotal,
              sumCritical = scansFilteredByWeeks[cwString].sumCritical,
              sumHigh = scansFilteredByWeeks[cwString].sumHigh,
              sumMedium = scansFilteredByWeeks[cwString].sumMedium,
              sumLow = scansFilteredByWeeks[cwString].sumLow,
              sumInfo = scansFilteredByWeeks[cwString].sumInfo;
            // scansOfWeek = scansFilteredByWeeks[cwString].scans;

            html += `<p>History based sum of findings:</p>
            <table class="table">
              <thead>
                <tr>
                  <th scope="col">Total</th>
                  <th scope="col">Critical</th>
                  <th scope="col">High</th>
                  <th scope="col">Medium</th>
                  <th scope="col">Low</th>
                  <th scope="col">Info</th>
                  <th scope="col">Sast/SCA</th>
                  <th scope="col">Container</th>
                  <th scope="col">Threat Modeling</th>
                </tr>
              </thead>
                <tbody>
                  <tr>
                    <td>${sumTotal}</td>
                    <td>${sumCritical}</td>
                    <td>${sumHigh}</td>
                    <td>${sumMedium}</td>
                    <td>${sumLow}</td>
                    <td>${sumInfo}</td>
                    <td>${sumSast}</td>
                    <td>${sumContainer}</td>
                    <td>${sumTM}</td>
                  </tr>
                </tbody>
            </table>`;

            if (scansOfCurrentWeek && scansOfCurrentWeek.length) {
              html += `<p>All scans uploaded in this week:</p>`;
              html += `<ul>`;

              for (const scan of scansOfCurrentWeek) {
                html += `<li>Scan from ${moment(scan.importTime).format(
                  "MMMM Do YYYY hh:mm:ss",
                )} of type <b>${scan.scannerName}</b> has ${
                  scan.numberTotalVulnerabilities
                } findings`;

                let numSlaViolations = 0;
                for (const f of scan.findings) {
                  if (f.sla_days_remaining < 0) {
                    // this is a "violation"
                    numSlaViolations++;
                  }
                }

                html += ` (Number of sla violations: ${numSlaViolations}) </li>`;
              }

              html += `</ul>`;
            }

            if (scansOfCurrentWeek.length === 0) {
              html += `<p style="color:red">No scan at all happened in this week!</p>`;
            }

            dialogObject.open(html);

            // TODO: takes too long. we need the db architecture logic...
            //   if (!scansOfWeek[scansOfWeek.length - 1]) {
            //     return;
            //   }
            //   let url = API_URL + `/${scansOfWeek[scansOfWeek.length - 1].id}`;
            //   fetch(url, {
            //     method: "GET",
            //   })
            //   .then(
            //     function (response) {
            //       console.log(response.json());
            //     },
            //     function (error) {
            //       console.log("ERRORRRRRRRRRRR", error.message); // => String
            //     },
            //   )
            //   .catch((error) => {
            //     console.log("ERRORRRRRRRRRRR", error.message); // => String
            //   });
          },
        },
      },
      plotOptions: {
        heatmap: {
          enableShades: false,
          // shadeIntensity: 0,
          // reverseNegativeShade: true,
          radius: 0,
          useFillColorAsStroke: true,
          colorScale: colorScale,
        },
      },
      dataLabels: {
        enabled: false,
      },
      stroke: {
        width: 1,
      },
      title: {
        text: "HeatMap Chart with Color Range",
      },
      // TODO: enabled: false makes click events break
      // because "seriesIndex" will be "-1" => WTF!?
      // tooltip: {
      //   enabled: false
      // }
    };

    CHART = new ApexCharts(document.querySelector("#heatmap"), options);
    CHART.render();
  }

  // do not fetch from server if already fetched
  // if (APPS) {
  //   return renderChart();
  // }

  fetchData().then((data) => {
    APPS = data;

    if (!APPS) {
      setLoading("");
      console.error("DATA", data);
      logToUI(logElement, "ERROR: no data from server");
      throw new Error("No data fetched from server, exit.");
    }

    if (APPS.length === 0) {
      setLoading("");
      console.log("DATA empty", data);
      return;
    }

    renderChart();
  });

  function generateData(app) {
    // everytime before we re-render we filter ALL scans
    const scans = filterScansByScannerType(app.scans, formProps.scanner);

    const scansFilteredByWeeks = normalizeScansForHistoricalView(
      scans,
      formProps.start_date,
      formProps.end_date,
    );

    const series = [];
    for (const calendarWeek of calendarWeeks) {
      let y = 0;
      const weekStr = "CW" + calendarWeek.week + " " + calendarWeek.year;

      // scansFilteredByWeeks is sometimes not filled at the current CW, so just ignore it
      if (!scansFilteredByWeeks[weekStr]) {
        continue;
      }
      const scansOfCurrentWeek = scansFilteredByWeeks[weekStr].scans;

      // Generate sum of all findings of the current week and calculate weighted average
      let sumCritical = scansFilteredByWeeks[weekStr].sumCritical,
        sumHigh = scansFilteredByWeeks[weekStr].sumHigh,
        sumMedium = scansFilteredByWeeks[weekStr].sumMedium,
        sumLow = scansFilteredByWeeks[weekStr].sumLow,
        sumInfo = scansFilteredByWeeks[weekStr].sumInfo,
        sumTotalVulnerabilities = scansFilteredByWeeks[weekStr].sumTotal;

      // for (const scanOfCurrentWeek of scansOfCurrentWeek) {
      //   sumCritical += scanOfCurrentWeek.numberCriticalVulnerabilities;
      //   sumHigh += scanOfCurrentWeek.numberHighVulnerabilities;
      //   sumMedium += scanOfCurrentWeek.numberMediumVulnerabilities;
      //   sumLow += scanOfCurrentWeek.numberLowVulnerabilities;
      //   sumInfo += scanOfCurrentWeek.numberInfoVulnerabilities;
      //   sumTotalVulnerabilities += scanOfCurrentWeek.numberTotalVulnerabilities;
      // }

      let weighted_average;

      if (sumTotalVulnerabilities > 0) {
        weighted_average =
          (sumCritical * factorCritical +
            sumHigh * factorHigh +
            sumMedium * factorMedium +
            sumLow * factorLow +
            sumInfo * factorInfo) /
          sumTotalVulnerabilities;

        y = weighted_average;
        // console.log("Average value", y);
      }

      // what to do if there is no scan in a week?
      if (scansOfCurrentWeek.length === 0) {
        y = 5.1;
      }

      if (scenarioSelect.value === "sla") {
        y = calculateSLAColorForWeek(scansOfCurrentWeek);
      }

      series.push({
        x: weekStr,
        y: y,
      });
    }

    return series;
  }
}
