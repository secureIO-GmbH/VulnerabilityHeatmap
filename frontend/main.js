/**
 * Main file for the frontend
 */
import moment from "moment";
import {
  COLOR_RANGE,
  logToUI,
  filterScansByScannerType,
  dialogObject,
  normalizeScansForHistoricalView,
} from "./helpers.js";

if (document) {
  if (!document.getElementById("start_date").value) {
    document.getElementById("start_date").value = moment()
      .subtract(3, "months")
      .toISOString()
      .substr(0, 10);
  }
  if (!document.getElementById("end_date").value) {
    document.getElementById("end_date").value = new Date()
      .toISOString()
      .substr(0, 10);
  }

  document.getElementById("scenarioHelp").addEventListener("click", () => {
    let html = `<h3>Scenarios</h3>
      <p>There are different scenarios possible which change the way the colors are calculated.</p>

      <h5>Scenario: "Weighted average" (based on history)</h5>
      <p>A weighted average is calculated based on the amount and severities of the cumulative findings of all scans until a certain calendar week. Each severity gets assigned a score. This method ensures the heatmap reflects both the volume and the severity of vulnerabilities. Example:</p>
      <pre>
      factorCritical = 5,
      factorHigh  = 4,
      factorMedium = 3,
      factorLow = 2,
      factorInfo = 1;

      weighted_average =
        (sumCritical * factorCritical +
        sumHigh * factorHigh +
        sumMedium * factorMedium +
        sumLow * factorLow +
        sumInfo * factorInfo) / sumTotalVulnerabilities

      Based on this "weighted_average" value, the colors are calculated:

      0 to 1 (Very Low): Green
      >1 to 2 (Low): light green
      >2 to 3 (Medium): Yellow
      >3 to 4 (High): Red
      >4 (Critical): Dark Red
      </pre>

      <p>To address the issue with the data display only per calendar week, a more accurate historical view of vulnerabilities for each scan type per calendar week, taking into account the findings from previous scans, a cumulative or rolling sum approach is implemented. This approach ensures that the current week's representation includes unresolved vulnerabilities from previous weeks, providing a more realistic view of the application's security posture over time.</p>
    `;
    html += "";
    dialogObject.open(html);
  });
}

const factorCritical = 5,
  factorHigh = 4,
  factorMedium = 3,
  factorLow = 2,
  factorInfo = 1;

let CHART;
const logElement = document.getElementById("log");
logToUI(logElement, "logs...");

let API_URL = "http://" + window.location.host + "/api/threadfix"; // http://10.109.64.133:9876/
let formProps, APPS;
const form = document.getElementById("form");
const selectScannerType = document.getElementById("scanner");

form.addEventListener("submit", (event) => {
  event.preventDefault();

  const formData = new FormData(event.target);
  formProps = Object.fromEntries(formData);

  // TODO: select which tool in the UI?
  // API_URL +=
  //   "kiuwan?appName=" +
  //   formProps.search +
  //   "&startDate=" +
  //   moment(formProps.start_date).unix() * 1000 +
  //   "&endDate=" +
  // 	moment(formProps.end_date).unix() * 1000;

  console.log("init with form data ", formProps);
  initHeatmap();
});

selectScannerType.addEventListener("change", function () {
  const formData = new FormData(form);
  formProps = Object.fromEntries(formData);
  initHeatmap();
});

// Fetch data from the node.js server, returns a promise with json data
function fetchData() {
  // test env means GitHub pages, no backend needed there
  if (NODE_ENV == "test") {
    return fetch(
      "/VulnerabilityHeatmap/backend/adapters/threadfix_response.json",
    )
      .then((r) => r.json())
      .then((json) => json.object);
  }

  let url = API_URL;
  // if (formProps.search) {
  //   url += `?appName=${formProps.search}`;
  // }
  return fetch(url, {
    method: "GET",
  })
    .then(
      function (response) {
        return response.json();
      },
      function (error) {
        console.log("ERRORRRRRRRRRRR", error.message); // => String
      },
    )
    .catch((error) => {
      console.log("ERRORRRRRRRRRRR", error.message); // => String
    });
}

function setLoading(loading) {
  document.querySelector("#heatmap").innerHTML = loading;
  document.getElementById("lds-roller").style.display = loading
    ? "inline-block"
    : "none";
}

function initHeatmap() {
  if (CHART) {
    CHART.destroy();
  }
  setLoading("loading...");

  // generate calendar weeks from start_date to end_date
  const calendarWeeks = [
    {
      week: moment(formProps.start_date).week(),
      year: moment(formProps.start_date).year(),
    },
  ];

  let timestamp = moment(formProps.start_date).unix();
  const lastTimestamp = moment(formProps.endDate).unix();

  let weeksToAdd = 1;
  while (timestamp <= lastTimestamp) {
    const date = moment(formProps.start_date).add(weeksToAdd, "weeks");
    timestamp = date.unix();
    weeksToAdd++;

    calendarWeeks.push({
      week: date.week(),
      year: date.year(),
    });
  }
  console.log(
    "Calendar weeks between ",
    moment(formProps.start_date).week(),
    moment(formProps.end_date).week(),
    calendarWeeks,
  );

  function renderChart() {
    setLoading("");

    const series = [];

    // let i = 0;
    for (const app of APPS) {
      if (
        formProps.search &&
        app.name.toLowerCase().indexOf(formProps.search.toLowerCase()) > -1
      ) {
        console.log("app: ", app, "# scans = " + app.scans.length);

        series.push({
          name: app.name,
          data: generateData(app),
        });
      } else if (!formProps.search && app.scans.length > 0) {
        series.push({
          name: app.name,
          data: generateData(app),
        });
      }
      // TODO: how many (which) apps?
      // if (++i > 20) break;
    }

    const options = {
      series: series,
      // will not be shown if there is only one app (row)
      legend: {
        show: true,
        position: "top",
      },
      chart: {
        height: "100%", // https://apexcharts.com/docs/options/chart/height/
        type: "heatmap",
        events: {
          /**
           * Clicking a box should display some information about the clicked calendar week
           * like how many scans, why is the color how it is etc
           *
           * TODO: fetch tf scan details by scanIds including CVEs, maybe fetch EPSS etc...
           */
          click: function (event, chartContext, config) {
            // The last parameter config contains additional information like `seriesIndex` and `dataPointIndex` for cartesian charts
            // console.log(event, chartContext, config);
            const appName = config.globals.seriesNames[config.seriesIndex];
            const cwString = config.globals.labels[config.dataPointIndex];
            let html = `<h3>Calendar Week: ${cwString}</h3>`;
            const appFound = APPS.find(function (app) {
              return app.name === appName;
            });

            const scansFilteredByWeeks = normalizeScansForHistoricalView(
              appFound.scans,
              formProps.start_date,
              formProps.end_date,
            );

            const scansOfCurrentWeek = scansFilteredByWeeks[cwString].scans;

            html += `<p>Amount of scans in this week: ${scansOfCurrentWeek.length}</p>`;

            let sumSast = scansFilteredByWeeks[cwString].sast,
              sumContainer = scansFilteredByWeeks[cwString].container,
              sumTM = scansFilteredByWeeks[cwString].tm,
              sumTotal = scansFilteredByWeeks[cwString].sumTotal,
              sumCritical = scansFilteredByWeeks[cwString].sumCritical,
              sumHigh = scansFilteredByWeeks[cwString].sumHigh,
              sumMedium = scansFilteredByWeeks[cwString].sumMedium,
              sumLow = scansFilteredByWeeks[cwString].sumLow,
              sumInfo = scansFilteredByWeeks[cwString].sumInfo;
            // scansOfWeek = scansFilteredByWeeks[cwString].scans;

            html += `<p>History based sum of findings:
            <br>Sum total: ${sumTotal}
            <br>Sum critical: ${sumCritical}
            <br>Sum high: ${sumHigh}
            <br>Sum medium: ${sumMedium}
            <br>Sum low: ${sumLow}
            <br>Sum info: ${sumInfo}
            <br> Sum SAST: ${sumSast}
            <br> Sum Container: ${sumContainer}
            <br> Sum Threat Modeling: ${sumTM}
            </p>`;

            html += `<p>All scans: </p>`;
            for (const scan of scansOfCurrentWeek) {
              html += `Scan from ${moment(scan.importTime).format(
                "MMMM Do YYYY",
              )} of type <b>${scan.scannerName}</b> has ${
                scan.numberTotalVulnerabilities
              } findings</br>`;
            }

            if (scansOfCurrentWeek.length === 0) {
              html += `<p style="color:red">No scan at all happened in this week!</p>`;
            }

            dialogObject.open(html);

            // TODO: takes too long. we need the db architecture logic...
            //   if (!scansOfWeek[scansOfWeek.length - 1]) {
            //     return;
            //   }
            //   let url = API_URL + `/${scansOfWeek[scansOfWeek.length - 1].id}`;
            //   fetch(url, {
            //     method: "GET",
            //   })
            //   .then(
            //     function (response) {
            //       console.log(response.json());
            //     },
            //     function (error) {
            //       console.log("ERRORRRRRRRRRRR", error.message); // => String
            //     },
            //   )
            //   .catch((error) => {
            //     console.log("ERRORRRRRRRRRRR", error.message); // => String
            //   });
          },
        },
      },
      plotOptions: {
        heatmap: {
          enableShades: false,
          // shadeIntensity: 0,
          // reverseNegativeShade: true,
          radius: 0,
          useFillColorAsStroke: true,
          colorScale: {
            ranges: [
              {
                from: 0,
                to: 0.9,
                name: "info",
                color: COLOR_RANGE.info,
              },
              {
                from: 0.91,
                to: 1.9,
                name: "low",
                color: COLOR_RANGE.low,
              },
              {
                from: 1.91,
                to: 2.9,
                name: "medium",
                color: COLOR_RANGE.medium,
              },
              {
                from: 2.91,
                to: 3.9,
                name: "high",
                color: COLOR_RANGE.high,
              },
              {
                from: 3.91,
                to: 1000000000000, // >
                name: "extreme",
                color: COLOR_RANGE.critical,
              },
            ],
          },
        },
      },
      dataLabels: {
        enabled: false,
      },
      stroke: {
        width: 1,
      },
      title: {
        text: "HeatMap Chart with Color Range",
      },
    };

    CHART = new ApexCharts(document.querySelector("#heatmap"), options);
    CHART.render();
  }

  if (APPS) {
    return renderChart();
  }

  fetchData().then((data) => {
    APPS = data;

    if (!APPS) {
      console.error("DATA", data);
      logToUI(logElement, "ERROR: no data from server");
      throw new Error("No data fetched from server, exit.");
    }

    renderChart();
  });

  function generateData(app) {
    // everytime before we re-render we filter ALL scans
    const scans = filterScansByScannerType(app.scans, formProps.scanner);

    const scansFilteredByWeeks = normalizeScansForHistoricalView(
      scans,
      formProps.start_date,
      formProps.end_date,
    );

    const series = [];
    for (const calendarWeek of calendarWeeks) {
      let y = 0;
      const weekStr = "CW" + calendarWeek.week + " " + calendarWeek.year;
      const scansOfCurrentWeek = scansFilteredByWeeks[weekStr].scans;

      // Generate sum of all findings of the current week and calculate weighted average
      let sumCritical = scansFilteredByWeeks[weekStr].sumCritical,
        sumHigh = scansFilteredByWeeks[weekStr].sumHigh,
        sumMedium = scansFilteredByWeeks[weekStr].sumMedium,
        sumLow = scansFilteredByWeeks[weekStr].sumLow,
        sumInfo = scansFilteredByWeeks[weekStr].sumInfo,
        sumTotalVulnerabilities = scansFilteredByWeeks[weekStr].sumTotal;

      // for (const scanOfCurrentWeek of scansOfCurrentWeek) {
      //   sumCritical += scanOfCurrentWeek.numberCriticalVulnerabilities;
      //   sumHigh += scanOfCurrentWeek.numberHighVulnerabilities;
      //   sumMedium += scanOfCurrentWeek.numberMediumVulnerabilities;
      //   sumLow += scanOfCurrentWeek.numberLowVulnerabilities;
      //   sumInfo += scanOfCurrentWeek.numberInfoVulnerabilities;
      //   sumTotalVulnerabilities += scanOfCurrentWeek.numberTotalVulnerabilities;
      // }

      let weighted_average;

      if (sumTotalVulnerabilities > 0) {
        weighted_average =
          (sumCritical * factorCritical +
            sumHigh * factorHigh +
            sumMedium * factorMedium +
            sumLow * factorLow +
            sumInfo * factorInfo) /
          sumTotalVulnerabilities;

        y = weighted_average;
        // console.log("Average value", y);
      }

      // what to do if there is no scan in a week? -> DARK RED!
      if (scansOfCurrentWeek.length === 0) {
        y = 100000000;
      }

      series.push({
        x: weekStr,
        y: y,
      });
    }

    return series;
  }
}
