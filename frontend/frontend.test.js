import assert from "assert";
import moment from "moment";
import {
  isInCalendarWeek,
  getScansOfCalendarWeek,
  normalizeScansForHistoricalView,
} from "./helpers.js";

describe("#isInCalendarWeek()", function () {
  it("should return true if a given timestamp is inside the given calendar week and year", function () {
    // Timestamps from threadfix are X1000
    // fn "unix() from moment NOT"
    let ts = moment("2023-01-01 18:06:03").unix() * 1000;
    let calendarWeek = 1;

    assert.equal(isInCalendarWeek(ts, calendarWeek, 2023), true);

    ts = moment("2023-01-02 18:06:03").unix() * 1000;
    assert.equal(isInCalendarWeek(ts, calendarWeek, 2023), true);

    ts = moment("2023-01-07 18:06:03").unix() * 1000;
    assert.equal(isInCalendarWeek(ts, calendarWeek, 2023), true);

    ts = moment("2022-01-07 18:06:03").unix() * 1000;
    assert.equal(isInCalendarWeek(ts, calendarWeek, 2023), false);

    ts = moment("2023-01-07 18:06:03").unix() * 1000;
    assert.equal(isInCalendarWeek(ts, calendarWeek, 2022), false);

    calendarWeek = 2;
    ts = moment("2023-01-08 18:06:03").unix() * 1000;
    assert.equal(isInCalendarWeek(ts, calendarWeek, 2023), true);

    calendarWeek = 51;
    ts = moment("2023-12-22 18:06:03").unix() * 1000;
    assert.equal(isInCalendarWeek(ts, calendarWeek, 2023), true);

    calendarWeek = 52;
    ts = moment("2023-12-24 18:06:03").unix() * 1000;
    assert.equal(isInCalendarWeek(ts, calendarWeek, 2023), true);

    // See comment above the function ;)
    calendarWeek = 1;
    ts = moment("2023-12-31 11:06:03").unix() * 1000;
    assert.equal(isInCalendarWeek(ts, calendarWeek, 2023), true);
  });
});

describe("#getScansOfCalendarWeek()", function () {
  it("should return only the scans which are in a given calendar week and year", function () {
    const scans = [
      {
        importTime: moment("2023-01-03 18:06:03").unix() * 1000,
      },
      {
        importTime: moment("2023-01-04 18:06:03").unix() * 1000,
      },
      {
        importTime: moment("2022-01-04 18:06:03").unix() * 1000,
      },
    ];

    const scansFound = getScansOfCalendarWeek(scans, 1, 2023);

    assert.equal(scansFound.length, 2);
  });
});

describe("#normalizeScansForHistoricalView()", function () {
  it("should normalize the scans of an app in order to provide historical views", function () {
    let scans = [
      // ============== CW1 2023
      {
        importTime: moment("2023-01-03 18:06:03").unix() * 1000,
        numberTotalVulnerabilities: 10,
        scannerName: "Trivy",
      },
      {
        importTime: moment("2023-01-03 18:06:03").unix() * 1000,
        numberTotalVulnerabilities: 8,
        scannerName: "Kiuwan",
      },
      {
        importTime: moment("2023-01-04 20:06:03").unix() * 1000,
        numberTotalVulnerabilities: 10,
        scannerName: "Kiuwan",
      },
      {
        importTime: moment("2023-01-03 18:06:03").unix() * 1000,
        numberTotalVulnerabilities: 10,
        scannerName: "KiuwanLibraries",
      },
      // ============== CW2 2023
      {
        importTime: moment("2023-01-08 18:06:03").unix() * 1000,
        numberTotalVulnerabilities: 4,
        scannerName: "Trivy",
      },
      // ============== CW3 2023
      {
        importTime: moment("2023-01-15 18:06:03").unix() * 1000,
        numberTotalVulnerabilities: 11,
        scannerName: "Trivy",
      },
      {
        importTime: moment("2023-01-15 18:06:03").unix() * 1000,
        numberTotalVulnerabilities: 2,
        scannerName: "Kiuwan",
      },
      // ============== CW4 2023
      {
        importTime: moment("2023-01-23 18:06:03").unix() * 1000,
        numberTotalVulnerabilities: 0,
        scannerName: "Trivy",
      },
      {
        importTime: moment("2023-01-23 18:06:03").unix() * 1000,
        numberTotalVulnerabilities: 0,
        scannerName: "Kiuwan",
      },
      {
        importTime: moment("2023-01-23 18:06:03").unix() * 1000,
        numberTotalVulnerabilities: 0,
        scannerName: "KiuwanLibraries",
      },
      // ============== CW5 2023
      {
        importTime: moment("2023-01-30 18:06:03").unix() * 1000,
        numberTotalVulnerabilities: 2,
        scannerName: "Trivy",
      },
      {
        importTime: moment("2023-01-30 18:06:03").unix() * 1000,
        numberTotalVulnerabilities: 2,
        scannerName: "Kiuwan",
      },
      {
        importTime: moment("2023-01-30 18:06:03").unix() * 1000,
        numberTotalVulnerabilities: 2,
        scannerName: "KiuwanLibraries",
      },

      // ============== CW6 2023 - NO SCANS. should keep data from week 5

      // ============== CW7 2023
      {
        importTime: moment("2023-02-13 18:06:03").unix() * 1000,
        numberTotalVulnerabilities: 5,
        scannerName: "Trivy",
      },
    ];

    const start_date = "2022-12-01";
    const end_date = "2023-06-01";

    const scansFilteredByWeeks = normalizeScansForHistoricalView(
      scans,
      start_date,
      end_date,
    );
    // console.log("RESULT", JSON.stringify(scansFilteredByWeeks, null, 2));

    assert.deepEqual(scansFilteredByWeeks["CW49 2022"], {
      scans: [],
      total: 0,
      sast: 0,
      container: 0,
    });
    assert.deepEqual(scansFilteredByWeeks["CW50 2022"], {
      scans: [],
      total: 0,
      sast: 0,
      container: 0,
    });
    assert.deepEqual(scansFilteredByWeeks["CW51 2022"], {
      scans: [],
      total: 0,
      sast: 0,
      container: 0,
    });
    assert.deepEqual(scansFilteredByWeeks["CW52 2022"], {
      scans: [],
      total: 0,
      sast: 0,
      container: 0,
    });
    assert.deepEqual(scansFilteredByWeeks["CW53 2022"], {
      scans: [],
      total: 0,
      sast: 0,
      container: 0,
    });

    // CW1 2023
    assert.equal(scansFilteredByWeeks["CW1 2023"].total, 30);
    assert.equal(scansFilteredByWeeks["CW1 2023"].container, 10);
    assert.equal(scansFilteredByWeeks["CW1 2023"].sast, 20); // sast means "sast&sca"

    // CW2 2023
    assert.equal(scansFilteredByWeeks["CW2 2023"].total, 24);
    assert.equal(scansFilteredByWeeks["CW2 2023"].container, 4);
    assert.equal(scansFilteredByWeeks["CW2 2023"].sast, 20); // still 20 from last week!

    // CW3 2023
    assert.equal(scansFilteredByWeeks["CW3 2023"].total, 23);
    assert.equal(scansFilteredByWeeks["CW3 2023"].container, 11);
    assert.equal(scansFilteredByWeeks["CW3 2023"].sast, 12);

    // CW4 2023
    assert.equal(scansFilteredByWeeks["CW4 2023"].total, 0);
    assert.equal(scansFilteredByWeeks["CW4 2023"].container, 0);
    assert.equal(scansFilteredByWeeks["CW4 2023"].sast, 0);

    // CW5 2023
    assert.equal(scansFilteredByWeeks["CW5 2023"].total, 6);
    assert.equal(scansFilteredByWeeks["CW5 2023"].container, 2);
    assert.equal(scansFilteredByWeeks["CW5 2023"].sast, 4);

    // CW6 2023 - keep from 5!
    assert.equal(scansFilteredByWeeks["CW6 2023"].total, 6);
    assert.equal(scansFilteredByWeeks["CW6 2023"].container, 2);
    assert.equal(scansFilteredByWeeks["CW6 2023"].sast, 4);

    // CW7 2023
    assert.equal(scansFilteredByWeeks["CW7 2023"].total, 9);
    assert.equal(scansFilteredByWeeks["CW7 2023"].container, 5);
    assert.equal(scansFilteredByWeeks["CW7 2023"].sast, 4);

    // CW8 2023 - no new scans, still same
    assert.equal(scansFilteredByWeeks["CW8 2023"].total, 9);
    assert.equal(scansFilteredByWeeks["CW8 2023"].container, 5);
    assert.equal(scansFilteredByWeeks["CW8 2023"].sast, 4);

    // CW23 2023
    assert.equal(scansFilteredByWeeks["CW23 2023"].total, 9);
    assert.equal(scansFilteredByWeeks["CW23 2023"].container, 5);
    assert.equal(scansFilteredByWeeks["CW23 2023"].sast, 4);
  });
});
