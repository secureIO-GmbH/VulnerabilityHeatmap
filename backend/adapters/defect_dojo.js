/**
 * Fetches all DefectDojo apps, engamements, tests and findings and normalize their data model
 * into the structure the heatmap needs ("unified data structure").
 */
import { DD_BASEURL, DD_APIKEY } from "../config.js";
import axios from "axios";
import moment from "moment";

function parseScanType(type) {
  if (type == "Trivy Scan") return "Trivy";
  if (type == "Kiuwan Scan") return "Kiuwan";
  if (type == "Kiuwan SCA Scan") return "KiuwanLibraries";
  if (type == "Acunetix Scan") return "Acunetix WVS";
  if (type.indexOf("IriusRisk") > -1) return "IriusRisk";
}

const axiosConfig = {
  mode: "no-cors",
  headers: {
    Authorization: "Token " + DD_APIKEY,
  },
};

/**
 * We need to fetch all products, for each product all its engagements
 * and for each engagements all tests, finally for each test its findings
 */
export async function fetchDataFromDefectDojo() {
  let res = await axios.get(DD_BASEURL + "products?limit=1000", axiosConfig);
  const products = res.data.results;

  console.log("products.length", products.length);
  // normalized data for the frontend
  const apps = [];

  for (const product of products) {
    // debugging
    // if (product.name !== "Test") {
    //   continue;
    // }

    const app = {
      name: product.name,
      tags: product.tags,
      scans: [],
    };

    res = await axios.get(
      DD_BASEURL + "engagements/?product=" + product.id,
      axiosConfig,
    );
    const engagements = res.data.results;

    console.log("fetching data for", product.name);

    for (const eng of engagements) {
      res = await axios.get(
        DD_BASEURL + "tests/?engagement=" + eng.id,
        axiosConfig,
      );
      const tests = res.data.results;

      for (const test of tests) {
        res = await axios.get(
          DD_BASEURL + "findings/?duplicate=false&test=" + test.id,
          axiosConfig,
        );
        const findings = res.data.results;
        const findingsFiltered = findings.filter(
          (f) =>
            !f.duplicate && f.active && !f.is_mitigated && !f.risk_accepted,
        );

        // remove some strings, to save space
        findingsFiltered.forEach(f => {
          f.references = "";
          f.description = f.description.slice(0, 100) + "...";
          delete f.hash_code;
        })

        app.scans.push({
          title: test.title,
          importTime: moment(test.created).unix() * 1000,
          date: test.created,
          scannerName: parseScanType(test.scan_type),
          numberTotalVulnerabilities: findingsFiltered.length,
          numberCriticalVulnerabilities: findingsFiltered.filter(
            (f) => f.severity === "Critical",
          ).length,
          numberHighVulnerabilities: findingsFiltered.filter(
            (f) => f.severity === "High",
          ).length,
          numberMediumVulnerabilities: findingsFiltered.filter(
            (f) => f.severity === "Medium",
          ).length,
          numberLowVulnerabilities: findingsFiltered.filter(
            (f) => f.severity === "Low",
          ).length,
          numberInfoVulnerabilities: findingsFiltered.filter(
            (f) => f.severity === "Info",
          ).length,

          findings: findingsFiltered,
        });
      }
    }

    apps.push(app);
  }

  return apps;
}
