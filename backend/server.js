import express from "express";
// const fs = require('fs');
import {
  // fetchKiuwanApps,
  fetchDataFromKiuwan,
} from "./adapters/kiuwan.js";
import { normalize } from "./adapters/threadfix.js";
import fs from "fs";
import axios from "axios";
import https from "https";
import http from "http";
import { THREADFIX_APIKEY, THREADFIX_BASEURL } from "./config.js";
//import data from "./adapters/threadfix_response.json" assert { type: "json" };
import path from "path";
import App from "./model/App.js";
import "./model/connection.js";

const env = process.env.NODE_ENV;

const agent = new https.Agent({
  rejectUnauthorized: false,
});
axios.defaults.httpsAgent = agent;

const __dirname = path.resolve(path.dirname(""));
const app = express();
const port = process.env.PORT || 9876;

let httpsPort, credentials;

if (env === "production") {
  httpsPort = process.env.HTTPS_PORT || 9443;

  // Load certificate and private key for HTTPS
  const privateKey = fs.readFileSync(
    "./backend/certs/mucsgappsec01.key",
    "utf8",
  );
  const certificate = fs.readFileSync(
    "./backend/certs/mucsgappsec01.crt",
    "utf8",
  );
  credentials = { key: privateKey, cert: certificate };

  // Middleware to redirect HTTP to HTTPS
  app.use((req, res, next) => {
    if (req.secure) {
      // Request is already secure, continue to the next middleware or route
      return next();
    }
    // Redirect HTTP to HTTPS with the correct port
    const host = req.headers.host.split(":")[0]; // Extract hostname without port
    res.redirect(`https://${host}:${httpsPort}${req.url}`);
  });
}

app.use("/", express.static(__dirname + "/"));

const axiosConfig = {
  mode: "no-cors",
  rejectUnauthorized: false,
  headers: {
    Authorization: "APIKEY " + THREADFIX_APIKEY,
  },
};

/**
 * Kiuwan API
 */
app.get("/api/kiuwan", async function (req, res) {
  console.log("fetching kiuwan data..", req.query.startDate, req.query.endDate);

  try {
    const data = await fetchDataFromKiuwan(
      req.query.appName,
      req.query.startDate,
      req.query.endDate,
    );
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(JSON.stringify(data));
  } catch (e) {
    console.log("ERROR", e);

    res.writeHead(500, { "Content-Type": "application/json" });
    res.end(JSON.stringify({ error: "An error occurred " + e.message }));
  }
});

/**
 * Threadfix API
 */
app.get("/api/threadfix", async function (req, res) {
  // TODO: implement mapping of names so we could fetch kiuwan scan details for a certain CW
  // const kiuwanApps = await fetchKiuwanApps();
  // console.log("????????", apps);

  function fetchDataFromApi(callback) {
    if (env === "production") {
      let url = THREADFIX_BASEURL + "rest/latest/applications";

      if (req.query.appName) {
        url += `/allTeamLookup?name=${req.query.appName}`;
      }

      axios
        .get(url, axiosConfig)
        .then(function (response) {
          callback(null, normalize(response.data));
        })
        .catch(function (error) {
          callback(error);
        });
    } else {
      //callback(null, normalize(data));
    }
  }

  console.log("fetching data..");

  fetchDataFromApi((error, data) => {
    if (error) {
      console.log("ERROR", error);

      res.writeHead(500, { "Content-Type": "text/plain" });
      res.end("An error occurred: " + error.message);
    } else {
      // Set the response header to indicate that the response will be in JSON format
      res.writeHead(200, { "Content-Type": "application/json" });

      // Send the JSON data as the response
      res.end(data ? JSON.stringify(data) : "[]");
    }
  });
});

/**
 * Defect Dojo API
 */
app.get("/api/dd", async function (req, res) {
  console.log("fetching data..");
  let apps;

  // TODO: not sure, do it on the FE
  if (req.query.name) {
    apps = await App.find().where("name").in(req.query.name);
  } else {
    apps = await App.find();
  }

  res.writeHead(200, { "Content-Type": "application/json" });
  res.end(apps ? JSON.stringify(apps) : "[]");
});

if (env === "production") {
  // Create the HTTPS server
  const httpsServer = https.createServer(credentials, app);

  // Listen on the specified port for HTTPS
  httpsServer.listen(httpsPort, () => {
    console.log(`HTTPS Server listening on port ${httpsPort}`);
  });
}

// Create an HTTP server that uses the same Express app
const httpServer = http.createServer(app);

httpServer.listen(port, () => {
  console.log(`HTTP Server listening on port ${port}`);
});
